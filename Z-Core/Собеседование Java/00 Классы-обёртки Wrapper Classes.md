2025032715:21
___
Date: 27-03-2025 | 15:21
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Классы-обёртки Wrapper Classes в Java

> В Java термин "Wrapper" (обёртка) обычно относится к **классам-обёрткам** (Wrapper Classes), которые используются для представления примитивных типов данных (`int`, `char`, `double` и т.д.) в виде объектов. Эти классы входят в стандартную библиотеку Java и находятся в пакете `java.lang`.

---
### Что такое Wrapper-классы?

> **Wrapper-классы** — это специальные классы, которые "оборачивают" примитивные типы в объекты. Для каждого из восьми примитивных типов в Java существует соответствующий Wrapper-класс:

|Примитивный тип|Wrapper-класс|
|---|---|
|byte|Byte|
|short|Short|
|int|Integer|
|long|Long|
|float|Float|
|double|Double|
|char|Character|
|boolean|Boolean|

**Пример:**
```java
int primitive = 42;         // Примитивный тип
Integer wrapper = 42;       // Объект-обёртка (автоупаковка)
```

---
### Зачем нужны Wrapper-классы?

Примитивные типы в Java — это не объекты, они просто значения, которые хранятся в памяти (обычно в стеке). Однако в некоторых ситуациях Java требует работы с объектами, а не с примитивами. Wrapper-классы решают эту проблему, предоставляя объектное представление примитивов. Вот основные причины их использования:

1. **Использование в коллекциях**:
    - Стандартные коллекции Java (например, `ArrayList`, `HashMap`) работают только с объектами, а не с примитивами. Вы не можете написать `ArrayList<int>`, но можете использовать `ArrayList<Integer>`.
```java
ArrayList<Integer> numbers = new ArrayList<>();
numbers.add(42); // Автоупаковка int в Integer
```

2. **Поддержка null**:
	- Примитивные типы не могут быть `null`, так как они хранят только значения. Wrapper-классы, будучи объектами, могут принимать значение `null`, что полезно для обозначения "отсутствия значения".
```java
Integer nullableInt = null; // OK
// int primitiveInt = null; // Ошибка компиляции
```

3. **Методы и утилиты**:
    - Wrapper-классы предоставляют полезные методы для работы с примитивными значениями. Например:
        - `Integer.parseInt("123")` — преобразует строку в `int`.
        - `Double.toString(3.14)` — преобразует `double` в строку.
        - `Character.isDigit('5')` — проверяет, является ли символ цифрой.
    - Эти методы недоступны для примитивных типов напрямую.

4. **Совместимость с объектно-ориентированным кодом**:
    - В некоторых API или библиотеках требуется передавать объекты. Например, методы, принимающие `Object`, не могут работать с примитивами, но могут с их обёртками.
```java
Object obj = 42; // Автоупаковка int в Integer
```

5. **Автоупаковка и распаковка**:
	- Начиная с Java 5, введены механизмы **autoboxing** (автоупаковка) и **unboxing** (распаковка), которые автоматически преобразуют примитивы в обёртки и наоборот. Это упрощает код.
```java
Integer wrapped = 10;  // Автоупаковка: int → Integer
int unwrapped = wrapped; // Распаковка: Integer → int
```

---
### Как это работает в памяти?

- Примитивный тип (например, `int`) хранит только значение (например, `42`) и занимает фиксированное место в стеке (4 байта для `int`).
- Wrapper-класс (например, `Integer`) — это объект, который создаётся в куче. Он содержит:
    - Значение примитивного типа (например, `42`).
    - Заголовок объекта (8-16 байт для метаданных JVM).
    - Ссылку на этот объект (4 или 8 байт), которая хранится в переменной в стеке.
- **Пример**:
```java
int primitive = 42;    // 4 байта в стеке
Integer wrapper = 42;  // Ссылка в стеке, объект в куче (~12-24 байта)
```

#### Автоупаковка и кэширование

- Для оптимизации некоторые Wrapper-классы кэшируют объекты для часто используемых значений:
    - `Integer` кэширует значения от `-128` до `127` (диапазон можно настроить через JVM-параметр).
    - `Boolean` кэширует `true` и `false`.
    - `Byte` кэширует все значения (от `-128` до `127`).
    
```java
Integer a = 100; // Используется кэшированный объект
Integer b = 100; // Тот же объект
System.out.println(a == b); // true (ссылки одинаковые из-за кэша)

Integer c = 200; // Новый объект
Integer d = 200; // Новый объект
System.out.println(c == d); // false (разные объекты)
```

---
### Плюсы и минусы Wrapper-классов
#### Плюсы:

- Совместимость с объектными API и коллекциями.
- Возможность использовать `null`.
- Дополнительные методы для работы с данными.
#### Минусы:

- Занимают больше памяти, чем примитивы (объект в куче vs значение в стеке).
- Меньшая производительность из-за автоупаковки/распаковки и создания объектов.
- Неосторожное использование может привести к `NullPointerException`:

```java
Integer x = null;
int y = x; // NullPointerException при распаковке
```

---
##### Пример использования
```java
import java.util.ArrayList;

public class WrapperExample {
    public static void main(String[] args) {
        // Коллекция с обёртками
        ArrayList<Integer> list = new ArrayList<>();
        list.add(10); // Автоупаковка
        list.add(null); // Примитив так не сделать

        // Преобразование строки в число
        String numberStr = "123";
        int primitive = Integer.parseInt(numberStr);
        Integer wrapper = Integer.valueOf(numberStr);

        System.out.println("Primitive: " + primitive); // 123
        System.out.println("Wrapper: " + wrapper);     // 123
    }
}
```

---
### Итог

Wrapper-классы в Java — это мост между примитивными типами и объектно-ориентированным миром. Они нужны для работы с коллекциями, передачи в методы, требующие объекты, и предоставления дополнительных функций. Однако их использование связано с накладными расходами на память и производительность, поэтому важно понимать, когда лучше использовать примитивы, а когда — обёртки.

-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
