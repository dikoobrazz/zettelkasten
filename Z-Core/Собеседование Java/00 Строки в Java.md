2025032815:31
___
Date: 28-03-2025 | 15:31
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Всё о троках в Java

> Строки в Java — это один из самых часто используемых типов данных, представленных классом `java.lang.String`. Они имеют особое место в языке благодаря своей неизменяемости, специальной обработке в JVM и пулу строк.

---
### Что такое строки в Java?

> **`String`** — это класс, представляющий последовательность символов. Он:

- **Неизменяемый (immutable)**: после создания содержимое строки нельзя изменить.
- **Финализированный (final)**: нельзя наследоваться от `String`.
- **Реализует интерфейсы**: `Serializable`, `Comparable<String>`, `CharSequence`.

**Пример:**
```java
String s = "Hello";
```

---
### Внутреннее устройство

Класс `String` внутри JVM реализован следующим образом (на примере Java 11+):

- **Поле `value`**:
    - До Java 7: `char[] value` — массив символов Unicode (UTF-16, 2 байта на символ).
    - С Java 7: `byte[] value` — массив байтов с кодировкой Latin-1 (1 байт) или UTF-16 (2 байта), в зависимости от содержимого.
    - Оптимизация: большинство строк в реальных приложениях содержат только Latin-1 символы (0-255), что экономит память.
- **Поле `coder`**:
    - Байтовое значение, указывающее кодировку `value`:
        - `0` — Latin-1.
        - `1` — UTF-16.
- **Поле `hash`**:
    - Кэшированный хэш-код (int), вычисляется один раз при первом вызове `hashCode()`.

**Пример внутренней структуры:**
```java
public final class String {
    private final byte[] value;  // Хранит символы
    private final byte coder;    // 0 или 1
    private int hash;            // Кэшированный хэш-код
    // ... другие поля и методы
}
```

Для строки `"Hello"`:

- `value = [72, 101, 108, 108, 111]` (байты для 'H', 'e', 'l', 'l', 'o' в Latin-1).
- `coder = 0` (Latin-1).

Для строки `"Привет"`:

- `value` — байты в UTF-16 (2 байта на символ).
- `coder = 1`.

---
### Где хранятся строки?

1. **Пул строк (String Pool)**:
    
    - Это специальная область в куче (heap), где хранятся **строковые литералы** (например, `"Hello"`).
    - До Java 7: пул находился в PermGen (постоянной памяти).
    - С Java 7: пул перемещён в основную кучу (heap), что упрощает управление памятью.
    - JVM кэширует литералы для экономии памяти: одинаковые литералы ссылаются на один объект.
```java
String s1 = "Hello";
String s2 = "Hello";
System.out.println(s1 == s2); // true (один объект из пула)
```

2. **Обычная куча (Heap)**:
	- Строки, созданные с помощью `new String()`, хранятся вне пула строк как отдельные объекты.
```java
String s3 = new String("Hello");
System.out.println(s1 == s3); // false (разные объекты)
```

3. **Интернирование**:
	- Метод `intern()` переносит строку в пул строк, возвращая ссылку на каноническую версию.
```java
String s4 = new String("Hello").intern();
System.out.println(s1 == s4); // true (s4 теперь в пуле)
```

---
### Как работают строки?

1. **Неизменяемость**:
    - Все операции, изменяющие строку (например, `concat()`, `replace()`), создают новый объект `String`, а исходный остаётся нетронутым.
```java
String s = "Hello";
s = s.concat(" World"); // Новый объект
System.out.println(s);   // "Hello World"
```

- Причина: безопасность (например, в качестве ключей `HashMap`) и оптимизация (кэширование).

2. **Конкатенация**:
	- Оператор `+` или `concat()` создают новый объект.
	- Компилятор оптимизирует + в `StringBuilder` для сложных выражений:
```java
String result = "Hello" + " " + "World"; // Преобразуется в StringBuilder
```

3. **Сравнение**:
	- `==` — сравнивает ссылки.
	- `equals()` — сравнивает содержимое.
```java
String s1 = "Hello";
String s2 = new String("Hello");
System.out.println(s1 == s2);      // false
System.out.println(s1.equals(s2)); // true
```

4. **Хэширование**:
	- `hashCode()` кэшируется в поле `hash`:
```java
int h = 0;
for (byte v : value) {
    h = 31 * h + (v & 0xff);
}
```

---
### Подводные камни

1. **Создание лишних объектов**:
    - Использование `new String("literal")` создаёт два объекта: один в пуле, другой в куче.
```java
String s = new String("Hello"); // Ненужный объект в куче
```

2. **Производительность при конкатенации**:
	- Многократное использование `+` в цикле создаёт много временных объектов:
```java
String s = "";
for (int i = 0; i < 1000; i++) {
    s += i; // Плохо: O(n²)
}
```

3. **Память и пул строк**:
    - Чрезмерное использование `intern()` может перегрузить пул строк, увеличивая время работы GC.
    - В Java 6 пул был ограничен PermGen, что могло вызвать `OutOfMemoryError`.
4. **Кодировка**:
    - Неправильная работа с не-Latin-1 символами может привести к увеличению размера строки (переход на UTF-16).
5. **Сравнение с `null`**:
    - Вызов `s.equals(null)` безопасен, но `null.equals(s)` вызовет `NullPointerException`.
6. **Подмена строк через рефлексию**:
    - Хотя `String` неизменяем, рефлексия позволяет изменить `value`, нарушая безопасность (но это не рекомендуется).

---
### Best Practices

1. **Используйте строковые литералы**:
    - Предпочитайте `"Hello"` вместо `new String("Hello")` для экономии памяти.
2. **Для конкатенации используйте `StringBuilder`**:
    - Особенно в циклах:
```java
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.append(i); // Хорошо: O(n)
}
String result = sb.toString();
```

3. **Осторожно с `intern()`**:
    - Используйте только для строк, которые часто повторяются и долгоживущие.
4. **Сравнение строк**:
    - Используйте `equals()` для содержимого, `==` только для проверки идентичности.
    - Для безопасного сравнения с `null` используйте `Objects.equals()`:
```java
String s1 = null;
String s2 = "Hello";
System.out.println(Objects.equals(s1, s2)); // false
```

5. **Неизменяемость как преимущество**:
    - Используйте строки как ключи в `HashMap` или элементы `HashSet`, не боясь изменений.
6. **Кэширование**:
    - Если строка используется многократно, сохраняйте её в переменной вместо повторного создания.
7. **Учитывайте кодировку**:
    - Если работаете с текстом, проверяйте, что используете правильные методы 
	    (`getBytes()`, `new String(bytes, charset)`).

---
### Итог

Строки в Java — это неизменяемые объекты с оптимизированным хранением (`byte[]` с Latin-1/UTF-16), кэшируемые в пуле строк для экономии памяти. Они обеспечивают безопасность и удобство, но требуют внимания к производительности (конкатенация, лишние объекты) и корректному сравнению. Следуя best practices, вы избежите типичных проблем и оптимизируете работу с ними.

-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
