2025032716:40
___
Date: 27-03-2025 | 16:40
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Всё о `HashMap` в Java

> **`HashMap`** в Java — это одна из самых популярных реализаций интерфейса `Map` из коллекций Java (пакет `java.util`). Она используется для хранения пар "ключ-значение" и обеспечивает быстрый доступ к данным благодаря хэшированию.

---
### Что такое HashMap?

> **`HashMap`** — это структура данных, которая реализует ассоциативный массив (словарь), где каждому ключу соответствует значение. Основные характеристики:

- **Ключи уникальны**: дубликаты ключей перезаписывают старые значения.
- **Неупорядоченность**: порядок элементов не гарантируется (в отличие от `LinkedHashMap`).
- **Допускает null**: один `null`-ключ и любое количество `null`-значений.
- **Несинхронизирован**: не потокобезопасен (для потоков используйте `Collections.synchronizedMap` или `ConcurrentHashMap`).

**Пример:**
```java
HashMap<String, Integer> map = new HashMap<>();
map.put("Alice", 25);
map.put("Bob", 30);
System.out.println(map.get("Alice")); // 25
```

---
### Как устроен HashMap?

> **`HashMap`** основан на концепции **хэш-таблицы**. Внутри он использует массив (называемый "таблицей"), где элементы распределяются по индексам на основе хэш-кода ключа. Если возникают коллизии (когда разные ключи попадают в один индекс), они разрешаются с помощью связных списков или деревьев (в Java 8+).
#### Основные компоненты:

1. **Массив баккетов (table)**:
    - Это внутренний массив типа `Node<K,V>[]`, где хранятся пары ключ-значение.
    - Размер массива — степень двойки (по умолчанию 16, растёт при необходимости).
2. **Узлы (Node)**:
    - Каждый элемент массива — это либо отдельный узел, либо начало структуры для разрешения коллизий.
    - Структура узла:
```java
static class Node<K,V> {
    final int hash;    // Хэш-код ключа
    final K key;       // Ключ
    V value;           // Значение
    Node<K,V> next;    // Ссылка на следующий узел (для коллизий)
}
```
3. **Хэш-функция**:
    - Преобразует хэш-код ключа (`key.hashCode()`) в индекс массива.
    - Формула: `index = (n - 1) & hash`, где `n` — длина массива, `hash` — скорректированный хэш-код.
4. **Баккеты (Buckets)**:
    - Это элементы массива, каждый из которых может содержать:
        - Ничего (пустой баккет).
        - Один узел (без коллизий).
        - Связный список узлов (при коллизиях).
        - Бинарное дерево (в Java 8+, если коллизий слишком много).

---
### Как работает HashMap?

#### 1. Добавление элемента (`put`):

- **Шаг 1**: Вычисляется хэш-код ключа с помощью `hashCode()`.
- **Шаг 2**: Хэш корректируется внутренней функцией `hash()` для уменьшения коллизий:
```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
- Здесь используется побитовое XOR верхних и нижних 16 бит, чтобы улучшить распределение.
- **Шаг 3**: Определяется индекс баккета: `index = (n - 1) & hash`.
- **Шаг 4**: Вставка в баккет:
    - Если баккет пуст, создаётся новый узел.
    - Если есть коллизия (одинаковый индекс):
        - Проверяется равенство ключей через `equals()`.
        - Если ключ совпадает, значение перезаписывается.
        - Если ключ новый, добавляется в связный список или дерево.
- **Шаг 5**: Проверка размера:
    - Если `size` превышает порог (`loadFactor * capacity`), массив увеличивается (resize).
#### 2. Получение элемента (`get`):

- **Шаг 1**: Вычисляется хэш-код ключа и индекс баккета.
- **Шаг 2**: В баккете ищется узел:
    - Если это список, проходит линейный поиск с `equals()`.
    - Если это дерево, используется бинарный поиск (`O(log n)`).
- **Шаг 3**: Возвращается значение или `null`, если ключ не найден.
#### 3. Удаление элемента (`remove`):

- Аналогично `get`, но узел удаляется из списка или дерева.

---
### Что такое баккеты?

> **Баккеты (buckets)** — это ячейки внутреннего массива `HashMap`, куда помещаются элементы.

Каждый баккет:

- Имеет индекс (от 0 до `capacity - 1`).
- Может быть:
    - Пустым (`null`).
    - Содержать один узел (`Node`).
    - Содержать цепочку узлов (linked list) при коллизиях.
    - Содержать красно-чёрное дерево (red-black tree) в Java 8+, если коллизий больше 8 (по умолчанию).

Пример:

- Если массив имеет размер 16, то есть 16 баккетов (индексы 0–15).
- Ключ `"Alice"` с хэш-кодом, приводящим к индексу 5, попадёт в баккет 5.
#### Переход от списка к дереву (Java 8+):

- Если в баккете больше 8 узлов (`TREEIFY_THRESHOLD`), и общий размер `HashMap` ≥ 64, связный список преобразуется в красно-чёрное дерево.
- Это улучшает время поиска с `O(n)` до `O(log n)`.
- При уменьшении до 6 узлов (`UNTREEIFY_THRESHOLD`) дерево обратно превращается в список.

---
### Нюансы работы

1. **Начальная ёмкость и коэффициент загрузки**:
    - По умолчанию: `capacity = 16`, `loadFactor = 0.75`.
    - Порог = `capacity * loadFactor` (например, 12 при размере 16).
    - При превышении порога массив удваивается (resize).
2. **Resize (увеличение размера)**:
    - Новый массив создаётся с удвоенной ёмкостью (например, 16 → 32).
    - Все элементы перераспределяются по новым баккетам (rehashing).
    - Это дорогостоящая операция (`O(n)`), поэтому важно выбирать подходящую начальную ёмкость.
3. **Коллизии**:
    - Возникают, когда разные ключи попадают в один баккет.
    - Разрешаются через списки или деревья.
    - Плохая реализация `hashCode()` увеличивает коллизии.
4. **Обработка `null`**:
    - `null`-ключ всегда помещается в баккет с индексом 0 (хэш = 0).

---
### Подводные камни

1. **Плохой `hashCode()**`:
    - Если `hashCode()` возвращает одинаковые значения для разных объектов, все ключи попадут в один баккет, и производительность упадёт до `O(n)`.
	- Пример:
```java
@Override
public int hashCode() { return 1; } // Все объекты в одном баккете
```

2. **Изменение ключей**:
	- Если ключ изменяется после добавления в `HashMap`, его хэш-код может измениться, и объект станет "невидимым".
```java
class Key {
    int value;
    @Override
    public int hashCode() { return value; }
    @Override
    public boolean equals(Object o) { return o instanceof Key && ((Key) o).value == value; }
}
Key k = new Key(); k.value = 1;
HashMap<Key, String> map = new HashMap<>();
map.put(k, "Value");
k.value = 2; // Изменяем ключ
System.out.println(map.get(k)); // null
```

3. **Производительность при resize**:
    - Частые увеличения массива замедляют работу. Установите начальную ёмкость 
	    (`new HashMap<>(1000)`), если ожидаете много элементов.
4. **Потокобезопасность**:
    - `HashMap` не синхронизирован. При одновременном изменении из нескольких потоков возможны ошибки (например, бесконечные циклы в списках).
5. **Итерация во время изменений**:
    - Изменение `HashMap` во время итерации (`put`, `remove`) может вызвать `ConcurrentModificationException`.

---
### Best Practices

1. **Правильная реализация `equals()` и `hashCode()`**:
    - Убедитесь, что контракт соблюдён, и хэш-код распределяет ключи равномерно.
2. **Выбор начальной ёмкости**:
    - Используйте конструктор с параметром `initialCapacity`, чтобы избежать частых resize:
```java
HashMap<String, Integer> map = new HashMap<>(1000);
```

3. **Неизменяемые ключи**:
    - Используйте неизменяемые объекты (например, `String`, `Integer`) как ключи.
4. **Потокобезопасность**:
    - Для многопоточной среды используйте `ConcurrentHashMap` или оберните `HashMap` в `Collections.synchronizedMap()`.
5. **Обработка коллизий**:
    - Если ожидаете много коллизий, проверьте качество `hashCode()` или увеличьте начальную ёмкость.

---
### Итог

`HashMap` — это мощная и эффективная структура данных с амортизированной сложностью `O(1)` для операций `put` и `get`, основанная на хэш-таблице с баккетами. Её устройство включает массив, узлы, списки и деревья для разрешения коллизий. Однако она требует внимания к качеству `hashCode()`, неизменяемости ключей и потокобезопасности. Правильное использование и настройка делают её незаменимой в Java.

-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
