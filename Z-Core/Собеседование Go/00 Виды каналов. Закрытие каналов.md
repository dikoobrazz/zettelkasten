2025030418:26
___
Date: 04-03-2025 | 18:26
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Какие бывают каналы? Кто должен закрывать канал?

### Какие бывают каналы?

1. **Небуферизированные каналы** (`make(chan T)`):
    - **Особенность**: Нет буфера, отправка (`ch <-`) и получение (`<-ch`) блокируют горутину, пока другая сторона не выполнит парную операцию.
    - **Когда использовать**: Для строгой синхронизации между горутинами.

```go
ch := make(chan int) // небуферизированный канал
go func() {
    ch <- 42 // блокируется, пока main не прочитает
}()
fmt.Println(<-ch) // блокируется, пока горутина не отправит
```

**Буферизированные каналы** (`make(chan T, n)`):

- **Особенность**: Имеют буфер емкостью nnn. Отправка не блокирует, пока буфер не заполнен, получение — пока есть данные.
- **Когда использовать**: Для асинхронной передачи данных с ограниченной очередью.

```go
ch := make(chan int, 2) // буферизированный канал на 2 элемента
ch <- 1 // не блокирует (буфер: [1])
ch <- 2 // не блокирует (буфер: [1, 2])
ch <- 3 // блокирует, буфер полон
fmt.Println(<-ch) // 1
```

**Односторонние каналы**:

- **Только для отправки** (`chan<- T`): Ограничивает канал только отправкой.
- **Только для получения** (`<-chan T`): Ограничивает канал только получением.
- **Когда использовать**: Для безопасности и читаемости в функциях.

```go
func sender(ch chan<- int) {
    ch <- 42 // только отправка
}
func receiver(ch <-chan int) {
    fmt.Println(<-ch) // только получение
}
ch := make(chan int)
go sender(ch)
receiver(ch)
```

**Закрытые каналы**:

- **Особенность**: После вызова `close(ch)` канал становится закрытым. Получение возвращает оставшиеся данные, затем нулевое значение типа и `ok=false.`
- **Когда использовать**: Для сигнала о завершении передачи данных.

```go
ch := make(chan int)
close(ch) // закрываем канал
v, ok := <-ch // 0, false
```

---
### Кто должен закрывать канал?
#### Правило

- **Закрывает тот, кто отправляет** (производитель, sender), а не получатель (consumer).
- **Почему**:
    - Отправитель знает, когда данные закончились, и может сигнализировать об этом.
    - Получатель не должен закрывать, так как он не знает, будет ли еще отправка, и это может вызвать панику (`panic: send on closed channel`).
##### Пример
```go
package main

import "fmt"

func sender(ch chan int) {
    for i := 1; i <= 3; i++ {
        ch <- i // отправляем данные
    }
    close(ch) // отправитель закрывает канал, сигнализируя конец
}

func main() {
    ch := make(chan int) // создаем канал
    go sender(ch)       // запускаем отправителя

    // получатель читает до закрытия
    for v := range ch {
        fmt.Println("Получено:", v)
    }
}
```

- **Комментарий**:
    - `sender` отправляет 1, 2, 3 и закрывает канал.
    - `main` читает через `range`, который автоматически завершается при закрытии.
    
##### Антипример (ошибка)
```go
ch := make(chan int)
go func() {
    fmt.Println(<-ch) // получатель читает
    close(ch)         // получатель закрывает — ошибка!
}()
ch <- 1 // panic: send on closed channel
time.Sleep(1 * time.Second)
```

- **Комментарий**: Получатель закрыл канал, а отправитель пытался отправить — вызвало панику.

---
### Коротко

- **Типы каналов**:
    1. Небуферизированные: строгая синхронизация.
    2. Буферизированные: очередь на nnn элементов.
    3. Односторонние: `chan<-` (отправка), `<-chan` (получение).
    4. Закрытые: после close().
- **Кто закрывает**: Отправитель, чтобы сигнализировать конец данных.

-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
