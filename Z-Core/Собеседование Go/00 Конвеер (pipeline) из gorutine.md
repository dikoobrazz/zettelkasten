2025030317:29
___
Date: 03-03-2025 | 17:29
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Как построить конвеер из горутин

> Построение конвейера (pipeline) из горутин в Go — это мощный способ организовать конкурентную обработку данных, где каждая стадия (этап) выполняется в отдельной горутине, передавая результаты следующей через каналы. Это похоже на сборочный конвейер на заводе: данные проходят через последовательные шаги обработки.

---
### Что такое конвейер из горутин?
#### Определение

- Конвейер — это цепочка горутин, где:  
    - Каждая горутина выполняет определенную задачу (этап).
    - Результаты передаются следующему этапу через **каналы**.
- Это реализация паттерна **Producer-Consumer**, где каждая стадия одновременно производит и потребляет данные.
#### Преимущества

- **Конкурентность**: Этапы работают параллельно.
- **Модульность**: Легко добавлять/убирать этапы.
- **Эффективность**: Данные обрабатываются потоком, без ожидания завершения всей задачи.

---
### Как построить конвейер?
#### Основные шаги

1. **Определите этапы**:  
    - Разбейте задачу на последовательные стадии (например, генерация → фильтрация → обработка).
2. **Создайте каналы**:  
    - Каждый канал соединяет выход одного этапа с входом следующего.
3. **Запустите горутины**:  
    - Каждая стадия — отдельная горутина, читающая из входного канала и пишущая в выходной.
4. **Синхронизируйте**:  
    - Используйте закрытие каналов или `WaitGroup` для завершения.

---
### Пример: Конвейер обработки чисел
#### Задача

- Генерируем числа (1-10).
- Фильтруем четные.
- Удваиваем их.
- Выводим результат.
##### Код с комментариями
```go
package main

import (
    "fmt"
    "sync"
)

// generator — первый этап: генерирует числа и отправляет их в канал
func generator(max int) <-chan int {
    out := make(chan int) // Создаем канал для вывода чисел
    go func() {           // Запускаем горутину для генерации
        defer close(out)  // Закрываем канал после завершения
        for i := 1; i <= max; i++ {
            out <- i // Отправляем число в канал
        }
    }()
    return out // Возвращаем канал как выход этапа
}

// filterEven — второй этап: фильтрует четные числа
func filterEven(in <-chan int) <-chan int {
    out := make(chan int) // Создаем канал для вывода четных чисел
    go func() {           // Запускаем горутину для фильтрации
        defer close(out)  // Закрываем выходной канал после завершения
        for num := range in { // Читаем числа из входного канала
            if num%2 == 0 {   // Проверяем, четное ли число
                out <- num    // Отправляем четное число в выходной канал
            }
        }
    }()
    return out // Возвращаем канал как выход этапа
}

// double — третий этап: удваивает числа
func double(in <-chan int) <-chan int {
    out := make(chan int) // Создаем канал для вывода удвоенных чисел
    go func() {           // Запускаем горутину для удваивания
        defer close(out)  // Закрываем выходной канал после завершения
        for num := range in { // Читаем числа из входного канала
            out <- num * 2    // Удваиваем число и отправляем в выходной канал
        }
    }()
    return out // Возвращаем канал как выход этапа
}

func main() {
    // Строим конвейер: генерация -> фильтрация -> удваивание
    genChan := generator(10)    // Первый этап: числа от 1 до 10
    filterChan := filterEven(genChan) // Второй этап: только четные
    doubleChan := double(filterChan)  // Третий этап: удвоение

    var wg sync.WaitGroup
    wg.Add(1) // Добавляем задачу для вывода результатов

    // Читаем результаты из последнего канала
    go func() {
        defer wg.Done() // Уменьшаем счетчик после завершения
        for result := range doubleChan { // Читаем из финального канала
            fmt.Println(result) // Выводим результат
        }
    }()

    wg.Wait() // Ждем завершения вывода
}
```

**Вывод**:
```text
4   // 2 * 2
8   // 4 * 2
12  // 6 * 2
16  // 8 * 2
20  // 10 * 2
```
#### Объяснение кода

1. **generator**:  
    - Создает канал и отправляет числа 1-10.
    - Закрывает канал (`defer close(out)`), чтобы следующий этап знал, что данные закончились.
2. **filterEven**:  
    - Читает из входного канала (`in`), фильтрует четные числа и отправляет их в выходной канал.
    - Закрывает свой канал после обработки всех данных.
3. **double**:  
    - Читает из входного канала, удваивает числа и отправляет их дальше.
    - Закрывает канал после завершения.
4. **Main**:  
    - Связывает этапы через каналы: `genChan → filterChan → doubleChan`.
    - Использует `WaitGroup`, чтобы дождаться вывода результатов.

---
### Как это работает?

- **Конкурентность**: Все этапы (генерация, фильтрация, удваивание) работают одновременно в разных горутинах.
- **Поток данных**: Каналы передают данные от одного этапа к следующему.
- **Синхронизация**: Закрытие каналов сигнализирует о завершении этапа, а `WaitGroup` ждет финального вывода.
#### Почему каналы?
  
- Каналы обеспечивают безопасную передачу данных между горутинами.
- Закрытие канала (`close`) автоматически уведомляет следующий этап о конце данных.
  
---
##### Расширенный пример: Обработка с ошибками
```go
package main

import (
    "fmt"
    "sync"
)

// StageResult — структура для передачи результата с ошибкой
type StageResult struct {
    Value int
    Err   error
}

// generator — генерирует числа с возможной ошибкой
func generator(max int) <-chan StageResult {
    out := make(chan StageResult)
    go func() {
        defer close(out)
        for i := 1; i <= max; i++ {
            if i == 3 { // Имитация ошибки на числе 3
                out <- StageResult{Value: i, Err: fmt.Errorf("ошибка на %d", i)}
                continue
            }
            out <- StageResult{Value: i, Err: nil}
        }
    }()
    return out
}

// process — обрабатывает числа, пропуская ошибки
func process(in <-chan StageResult) <-chan StageResult {
    out := make(chan StageResult)
    go func() {
        defer close(out)
        for res := range in {
            if res.Err != nil { // Пропускаем ошибочные результаты
                continue
            }
            out <- StageResult{Value: res.Value * 2, Err: nil}
        }
    }()
    return out
}

func main() {
    genChan := generator(5)    // Генерируем числа 1-5
    procChan := process(genChan) // Удваиваем числа

    var wg sync.WaitGroup
    wg.Add(1)
    go func() {
        defer wg.Done()
        for res := range procChan {
            if res.Err != nil {
                fmt.Printf("Ошибка: %v\n", res.Err)
            } else {
                fmt.Printf("Результат: %d\n", res.Value)
            }
        }
    }()

    wg.Wait()
}
```

**Вывод**:
```text
Результат: 2   // 1 * 2
Результат: 4   // 2 * 2
Результат: 8   // 4 * 2
Результат: 10  // 5 * 2
```

- **Комментарии**:  
    - Ошибка на числе 3 пропущена, остальные обработаны.
    - `StageResult` добавляет обработку ошибок в конвейер.

---
### Лучшие практики

1. **Закрывайте каналы**: Используйте `defer close(out)` в каждой стадии для корректного завершения.
2. **Используйте буферизацию**: Если этап медленный, буферизируйте каналы (`make(chan T, n)`), чтобы избежать блокировки.
3. **Обрабатывайте ошибки**: Передавайте их через каналы, как в расширенном примере.
4. **Ограничивайте горутины**: Не создавайте слишком много этапов без необходимости.
5. **Синхронизация**: `WaitGroup` для ожидания финального этапа.
  
---
### Итог

Конвейер из горутин:

- Это цепочка этапов, где каждая стадия — горутина, соединенная каналами.
- Работает конкурентно, передавая данные от этапа к этапу.
- Построение: Определите этапы, свяжите их каналами, запустите в горутинах.

Это удобно для потоковой обработки (логи, данные, запросы).

-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
