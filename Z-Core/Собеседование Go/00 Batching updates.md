2025030218:13
___
Date: 02-03-2025 | 18:13
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Как за**бэ**тчить кучу апдейтов в таблице

**batching** - бъединить множество операций `UPDATE` в одну транзакцию или запрос для повышения производительности в базе данных. Это называется **батчинг (batching)**.

### Что такое батчинг и зачем он нужен?

- **Батчинг** — это выполнение множества операций (например, `UPDATE`) одним запросом или в одной транзакции вместо отдельных вызовов.
- **Зачем**:  
    - Уменьшить накладные расходы на сетевые запросы.
    - Снизить нагрузку на базу данных.
    - Ускорить выполнение (особенно при большом количестве обновлений).    
  
Без батчинга каждый `UPDATE` — это отдельный запрос, что медленно и неэффективно.

---
### Способы батчинга апдейтов

#### 1. Единый запрос с CASE

- Используем `UPDATE` с конструкцией `CASE`, чтобы обновить несколько строк одним запросом.
- Подходит, если нужно обновить разные значения в одном столбце на основе условия.

Пример: Допустим, таблица `users`:
```sql
CREATE TABLE users (
    id INT PRIMARY KEY,
    balance INT
);
INSERT INTO users (id, balance) VALUES (1, 100), (2, 200), (3, 300);
```

Нужно обновить `balance` для нескольких ID:

- `id=1` → `balance=150`.
- `id=2` → `balance=250`.
- `id=3` → `balance=350`.

**Запрос:**
```sql
UPDATE users
SET balance = CASE id
    WHEN 1 THEN 150
    WHEN 2 THEN 250
    WHEN 3 THEN 350
    ELSE balance
END
WHERE id IN (1, 2, 3);
```

- Один запрос обновляет все строки сразу.
#### 2. Временная таблица + UPDATE ... JOIN

- Создаем временную таблицу с новыми значениями и применяем их одним UPDATE с JOIN.
- Подходит для больших объемов данных.

**Пример:**
```sql
-- Создаем временную таблицу
CREATE TEMP TABLE updates (
    id INT,
    new_balance INT
);
INSERT INTO updates (id, new_balance) VALUES
    (1, 150),
    (2, 250),
    (3, 350);

-- Обновляем основную таблицу
UPDATE users u
JOIN updates upd ON u.id = upd.id
SET u.balance = upd.new_balance;

DROP TABLE updates;
```

#### 3. Транзакция с множеством UPDATE

- Выполняем все апдейты в одной транзакции, но как отдельные запросы.
- Меньше накладных расходов на установку соединений.

**Пример:**
```sql
BEGIN;
UPDATE users SET balance = 150 WHERE id = 1;
UPDATE users SET balance = 250 WHERE id = 2;
UPDATE users SET balance = 350 WHERE id = 3;
COMMIT;
```

#### 4. Массовая вставка в буфер (для специфичных СУБД)

- Некоторые базы (например, PostgreSQL) поддерживают `COPY` или массовые операции через драйверы.
- Нужно сначала собрать данные, затем применить их.

---
### Как выбрать подход?
  
1. **Маленький объем обновлений (до 100)**:  
    - Используйте `CASE` (простота, один запрос).
2. **Средний объем (100-1000)**:  
    - Транзакция с `UPDATE` (хороший баланс скорости и читаемости).
3. **Большой объем (1000+)**:  
    - Временная таблица (масштабируемость, меньше накладных расходов).
#### Производительность

- `CASE`: Один запрос, но сложность растет с числом условий.
- Транзакция: Много запросов, но в одном соединении.
- Временная таблица: Оптимизировано для массовых операций.

---
### Итог
  
**Батчинг апдейтов в таблице:**

- **CASE**: Один запрос с условиями.
- **Транзакция**: Множество запросов в одном пакете.
- **Временная таблица**: Массовое обновление через промежуточную структуру.
  
В Go это реализуется через db.Exec или подготовленные запросы в транзакциях. Выбор зависит от объема данных и требований к скорости.

-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
