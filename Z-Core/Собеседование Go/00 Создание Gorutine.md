2025030314:30
___
Date: 03-03-2025 | 14:30
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## О чем ты думаешь когда создаешь горутину?

### 1. Зачем мне горутина?

- **Цель**: Нужно ли мне конкурентность? Это I/O-задача (например, запрос к базе), вычисление или обработка события?
- **Пример**: Если я читаю файл или жду ответа от API, горутина позволяет не блокировать основной поток.

```go
go func() {
    data, _ := os.ReadFile("log.txt")
    fmt.Println(string(data))
}()
```

- **Вопрос**: Можно ли обойтись без неё? Если задача тривиальна и синхронна, горутина может быть избыточной.
### 2. Как я буду синхронизировать?

- **Проблема**: Горутины работают независимо, и без синхронизации результат может быть потерян или порядок нарушен.
- **Решение**:  
1. **Каналы**: Для передачи данных или сигналов.
```go
    ch := make(chan string)
go func() {
    ch <- "Готово"
}()
fmt.Println(<-ch) // Жду результата
```

2. **WaitGroup**: Для ожидания завершения.
```go 
var wg sync.WaitGroup
wg.Add(1)
go func() {
    defer wg.Done()
    fmt.Println("Работаю")
}()
wg.Wait()
```

- **Думаю**: Нужен ли мне результат? Если да, то как его получить? Если нет, как убедиться, что горутина завершилась?
### 3. Что с производительностью?

- **Нагрузка**: Горутины легкие (2 КБ стека), но миллионы горутин могут исчерпать память.
- **Параллелизм**: Если `GOMAXPROCS > 1`, горутины могут работать на разных ядрах, но это зависит от задачи.
- **Пример**: Для CPU-bound задач (вычисления) проверяю, стоит ли распараллеливать.
```go
runtime.GOMAXPROCS(4)
for i := 0; i < 4; i++ {
    go heavyComputation()
}
```

- **Вопрос**: Не создаю ли я слишком много горутин? Будет ли выигрыш?
### 4. Безопасность данных

- **Race Condition**: Если горутина изменяет общие данные, это может привести к гонкам.
- **Решение**:  
    - Избегать общего состояния.
    - Использовать `sync.Mutex`:
```go
var counter int
var mu sync.Mutex
go func() {
    mu.Lock()
    counter++
    mu.Unlock()
}()
```

- **Думаю**: Есть ли общие ресурсы? Как защитить их?
### 5. Завершение программы

- **Проблема**: Если `main` завершится раньше горутин, они не успеют выполниться.
- **Решение**: Использовать синхронизацию (каналы, `WaitGroup`) или `time.Sleep` (временный костыль).
- **Пример**:
```go
go func() {
    time.Sleep(1 * time.Second)
    fmt.Println("Горутина")
}()
time.Sleep(2 * time.Second) // Жду, но это не лучший способ
```
- **Вопрос**: Как гарантировать, что нужная работа завершится?
### 6. Обработка ошибок

- **Проблема**: Ошибки в горутине не передаются в `main` автоматически.
- **Решение**: Использовать канал для ошибок.
```go
errCh := make(chan error)
go func() {
    err := someFunc()
    errCh <- err
}()
if err := <-errCh; err != nil {
    fmt.Println("Ошибка:", err)
}
```

- **Думаю**: Как мне узнать, что горутина упала? Как обработать это?
### 7. Контекст и отмена

- **Проблема**: Горутина может работать дольше, чем нужно (например, при тайм-ауте).
- **Решение**: Использовать `context` для отмены
```go
ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
defer cancel()
go func() {
    select {
    case <-time.After(2 * time.Second):
        fmt.Println("Работа завершена")
    case <-ctx.Done():
        fmt.Println("Отменено:", ctx.Err())
    }
}()
time.Sleep(2 * time.Second)
```

- **Вопрос**: Нужно ли мне контролировать время жизни горутины?

---
#### Пример: Всё вместе
```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

func worker(ctx context.Context, id int, wg *sync.WaitGroup, results chan<- string) {
    defer wg.Done()
    select {
    case <-time.After(500 * time.Millisecond):
        results <- fmt.Sprintf("Работник %d завершил", id)
    case <-ctx.Done():
        results <- fmt.Sprintf("Работник %d отменен: %v", id, ctx.Err())
    }
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 300*time.Millisecond)
    defer cancel()

    var wg sync.WaitGroup
    results := make(chan string, 3)

    for i := 1; i <= 3; i++ {
        wg.Add(1)
        go worker(ctx, i, &wg, results)
    }

    go func() {
        wg.Wait()
        close(results)
    }()

    for result := range results {
        fmt.Println(result)
    }
}
```


- **Вывод**:
```text
Работник 1 отменен: context deadline exceeded
Работник 2 отменен: context deadline exceeded
Работник 3 отменен: context deadline exceeded
```

- Здесь есть синхронизация, отмена и обработка результатов.

---
### Итог: О чем думаю?

Когда создаю горутину, я:

1. Определяю цель (конкурентность нужна?).
2. Планирую синхронизацию (каналы, `WaitGroup`).
3. Учитываю производительность (не переборщить).
4. Защищаю данные (безопасность).
5. Контролирую завершение (чтобы не потерять).
6. Обрабатываю ошибки (через каналы).
7. Думаю об отмене (через `context`).

Горутины — простой инструмент, но требуют внимания к деталям.


-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
