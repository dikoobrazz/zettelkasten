2025030221:29
___
Date: 02-03-2025 | 21:29
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Что такое вложенные транзакции и как с ними работать?

> **Вложенные транзакции в базах данных** — это механизм, позволяющий создавать транзакции внутри других транзакций, чтобы управлять изменениями данных с большей гибкостью. Они полезны для разделения сложных операций на подзадачи, каждая из которых может быть независимо завершена или откатана.

---
### Что такое вложенные транзакции?

#### Определение

- **Вложенная транзакция** — это транзакция, которая начинается внутри уже существующей (внешней) транзакции.
- Она позволяет изолировать часть работы внутри основной транзакции, с возможностью частичного коммита или отката, не затрагивая всю внешнюю транзакцию.
#### Как это работает?
  
- **Внешняя транзакция** — "родительская", а вложенные — "дочерние".
- В большинстве СУБД (например, PostgreSQL) вложенные транзакции реализуются через **точки сохранения** (SAVEPOINT), а не как полностью независимые транзакции.
- Полный откат внешней транзакции отменяет все вложенные, но вложенная может быть откатана независимо.

---
### Механизм в PostgreSQL: SAVEPOINT

PostgreSQL не поддерживает "настоящие" вложенные транзакции (отдельные `BEGIN` 
внутри `BEGIN`), но использует точки сохранения для имитации этого поведения.  
#### Синтаксис

- `SAVEPOINT имя`: Создает точку сохранения внутри транзакции.
- `RELEASE SAVEPOINT имя`: Удаляет точку сохранения (фиксация изменений до этой точки).
- `ROLLBACK TO SAVEPOINT имя`: Откатывает изменения до указанной точки, сохраняя внешнюю транзакцию.
#### Пример
```sql
BEGIN;

INSERT INTO users (name) VALUES ('Alice');

SAVEPOINT sp1;
INSERT INTO users (name) VALUES ('Bob');
-- Ошибка или условие
ROLLBACK TO SAVEPOINT sp1; -- Откатываем только Bob

INSERT INTO users (name) VALUES ('Charlie');

COMMIT;
```

**Результат**: В таблице будет только `Alice` и `Charlie`, так как вставка `Bob` откатилась.

---
### Как работают вложенные транзакции?

1. **Начало внешней транзакции**:  
    - `BEGIN` открывает основную транзакцию.
2. **Создание вложенной**:  
    - `SAVEPOINT` фиксирует текущее состояние внутри транзакции.
3. **Изменения**:  
    - Выполняются операции после точки сохранения.
4. **Управление**:  
    - `ROLLBACK TO SAVEPOINT` отменяет изменения до точки, не затрагивая внешнюю транзакцию.
    - `COMMIT` фиксирует всё, включая изменения после всех точек.
#### Ограничения

- Нет полной изоляции: вложенная транзакция не независима от внешней.
- Откат внешней транзакции (`ROLLBACK`) отменяет все вложенные изменения.
  
---
### Когда использовать?

1. **Частичная обработка ошибок**:  
    - Если часть операции может завершиться неудачей, но остальное нужно сохранить.
    - Пример: Обновление нескольких таблиц, где одна часть может быть откатана.
2. **Разделение сложных операций**:  
    - Разбиение большой транзакции на логические блоки.
    - Пример: Пакетная обработка данных с возможностью отмены отдельных шагов.
3. **Тестирование или отладка**:  
    - Проверка изменений без фиксации всей транзакции.
#### Пример
  
- Транзакция заказа: добавление клиента, создание заказа, списание денег. Если списание не удалось, откатываем только его.

---
### Работа с вложенными транзакциями в Go

PostgreSQL через database/sql поддерживает вложенные транзакции через `SAVEPOINT`.
#### Пример в Go
```go
package main

import (
    "database/sql"
    "fmt"
    _ "github.com/lib/pq"
)

func main() {
    db, err := sql.Open("postgres", "user=pguser dbname=test sslmode=disable")
    if err != nil {
        fmt.Println(err)
        return
    }
    defer db.Close()

    // Начинаем внешнюю транзакцию
    tx, err := db.Begin()
    if err != nil {
        fmt.Println("Ошибка начала транзакции:", err)
        return
    }
    defer tx.Rollback() // Откат, если не COMMIT

    // Вставка первой записи
    _, err = tx.Exec("INSERT INTO users (name) VALUES ($1)", "Alice")
    if err != nil {
        fmt.Println("Ошибка вставки Alice:", err)
        return
    }

    // Создаем точку сохранения
    _, err = tx.Exec("SAVEPOINT sp1")
    if err != nil {
        fmt.Println("Ошибка создания SAVEPOINT:", err)
        return
    }

    // Пробуем вставить вторую запись
    _, err = tx.Exec("INSERT INTO users (name) VALUES ($1)", "Bob")
    if err != nil {
        fmt.Println("Ошибка вставки Bob, откатываем:", err)
        tx.Exec("ROLLBACK TO SAVEPOINT sp1")
    } else {
        tx.Exec("RELEASE SAVEPOINT sp1")
    }

    // Вставка третьей записи
    _, err = tx.Exec("INSERT INTO users (name) VALUES ($1)", "Charlie")
    if err != nil {
        fmt.Println("Ошибка вставки Charlie:", err)
        return
    }

    // Фиксируем транзакцию
    err = tx.Commit()
    if err != nil {
        fmt.Println("Ошибка COMMIT:", err)
        return
    }
    fmt.Println("Транзакция завершена успешно")
}
```

#### Как работает?

- Внешняя транзакция: `tx.Begin()`.
- Точка сохранения: `SAVEPOINT sp1`.
- Если вставка `Bob` не удалась, откатываем до `sp1`, но сохраняем `Alice`.
- `Charlie` добавляется после, и всё фиксируется через `COMMIT`.

---
### Плюсы и минусы

#### Плюсы

- Гибкость: частичный откат без потери всей работы.
- Упрощение обработки ошибок в сложных операциях.
- Логика на уровне базы, независимо от приложения.
#### Минусы

- Нет полной изоляции: вложенные транзакции зависят от внешней.
- Усложняет отладку: больше точек управления.
- Производительность: дополнительные команды (`SAVEPOINT`, `ROLLBACK TO`) добавляют накладные расходы.
  
---
### Итог
  
Вложенные транзакции в PostgreSQL — это точки сохранения (`SAVEPOINT`), позволяющие:

- Откатывать часть изменений внутри транзакции.
- Управлять сложными операциями с ошибками.
  
Используйте их для:

- Частичной обработки ошибок.
- Разделения транзакций на подзадачи.

В Go это реализуется через `tx.Exec` с командами `SAVEPOINT` и `ROLLBACK TO`


-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
