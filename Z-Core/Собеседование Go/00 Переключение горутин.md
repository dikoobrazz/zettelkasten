2025030417:36
___
Date: 04-03-2025 | 17:36
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Переключение горутин

### Когда горутина переключается?

Планировщик Go (часть runtime) управляет переключением контекста между горутинами. Это происходит в следующих ситуациях:

1. **Блокировка (I/O, каналы, мьютексы)**:
    - Горутина ожидает внешнего события (например, чтение из канала, файла или сети).
    - Планировщик паркует её и переключается на другую готовую горутину.
2. **Таймер (временные точки уступки)**:
    - Если горутина работает долго, планировщик может прервать её (примерно каждые 10 мс или при определенных операциях) и переключиться на другую.
3. **Явная уступка (runtime.Gosched)**:
    - Горутина вручную уступает управление, вызывая `runtime.Gosched()`.
4. **Системные вызовы**:
    - При блокирующем системном вызове (например, `syscall`) горутина приостанавливается, и создается временный поток для другой горутины.

---

##### Пример кода с комментариями
```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func worker(id int, ch chan int) {
    for i := 0; i < 3; i++ {
        fmt.Printf("Горутина %d: шаг %d\n", id, i)
        if i == 1 {
            // Явная уступка управления другой горутине
            runtime.Gosched() // точка переключения: дает шанс другой горутине
        }
    }

    // Блокировка на канале
    <-ch // точка переключения: горутина ждет данные из канала
    fmt.Printf("Горутина %d: разблокирована\n", id)
}

func busyWorker(id int) {
    // Долгая работа без явных точек уступки
    for i := 0; i < 1000000; i++ {
        _ = i // имитация CPU-интенсивной задачи
    }
    fmt.Printf("Горутина %d: завершила долгую работу\n", id)
}

func main() {
    // Ограничиваем выполнение одним потоком ОС для демонстрации переключения
    runtime.GOMAXPROCS(1)

    ch := make(chan int) // небуферизированный канал для синхронизации

    // Запускаем первую горутину с блокировкой
    go worker(1, ch) // первая горутина начнет работу

    // Запускаем вторую горутину с CPU-задачей
    go busyWorker(2) // вторая горутина может быть переключена при таймере

    // Даем время для работы горутин
    time.Sleep(100 * time.Millisecond)

    // Разблокируем первую горутину
    ch <- 42 // точка переключения: первая горутина возобновляется

    // Ждем завершения всех операций
    time.Sleep(200 * time.Millisecond)
    fmt.Println("main завершился")
}
```

**Вывод (примерный)**
```text
Горутина 1: шаг 0
Горутина 1: шаг 1
Горутина 2: завершила долгую работу
Горутина 1: шаг 2
Горутина 1: разблокирована
main завершился
```

---
### Объяснение переключений в коде

1. **Блокировка на канале (<-ch)**:
    - В `worker` горутина 1 доходит до `<-ch` и блокируется, так как канал пуст.
    - Планировщик переключается на горутину 2 (`busyWorker`), пока первая ждет.
2. **Явная уступка (runtime.Gosched)**:
    - На шаге `i == 1` в `worker` вызывается `Gosched()`, что дает шанс горутине 2 начать или продолжить работу.
3. **Таймер**:
    - В `busyWorker` долгая работа может быть прервана планировщиком (~10 мс), если она занимает CPU без уступок.
    - Это зависит от внутренних точек проверки (например, вызовы функций).
4. **Разблокировка**:
    - Когда `main` отправляет `42` в канал (`ch <- 42`), горутина 1 разблокируется, и планировщик переключается обратно на неё.

---

### Коротко: Когда переключается?

- **Блокировка**: Ожидание канала, I/O, мьютекса.
- **Таймер**: Долгая работа без уступок (~10 мс).
- **Уступка**: Вызов `runtime.Gosched()`.
- **Syscall**: Блокирующий системный вызов.

Планировщик Go переключает горутины в этих точках, чтобы обеспечить конкурентность.

-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
