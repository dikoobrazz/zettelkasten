2025030217:32
___
Date: 02-03-2025 | 17:32
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Как работает составной индекс в BD?

> **Составной индекс (composite index)** в базах данных — это индекс, который охватывает несколько столбцов таблицы одновременно. Он позволяет ускорить запросы, использующие комбинации этих столбцов в условиях `WHERE`, `JOIN`, `ORDER` `BY` и других операциях.

---
### Что такое составной индекс?

> **Составной индекс** — это единая структура данных (обычно B-дерево), которая хранит упорядоченные значения комбинации нескольких столбцов и ссылки на соответствующие строки таблицы. Порядок столбцов в индексе важен, так как он определяет, как данные сортируются и как база будет их искать.
  
#### Пример создания:
```sql
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INT,
    order_date DATE,
    amount INT
);

CREATE INDEX idx_user_date ON orders(user_id, order_date);
```

- Индекс `idx_user_date` включает два столбца: `user_id` и `order_date`.
  
---
### Как работает составной индекс?

#### 1. Структура

- Составной индекс — это B-дерево (или B+-дерево в большинстве СУБД), где ключи формируются как кортежи `(столбец1, столбец2, ...)`.
- Данные в дереве упорядочены:  
    - Сначала по первому столбцу (`user_id`).
    - Внутри каждого значения первого столбца — по второму (`order_date`).
- Листья содержат ссылки на строки таблицы (`ROWID`).
#### Пример данных:

|id|user_id|order_date|amount|
|---|---|---|---|
|1|100|2023-01-01|50|
|2|100|2023-01-02|75|
|3|200|2023-01-01|30|
|4|200|2023-01-03|20|

Индекс `idx_user_date` будет выглядеть как дерево с ключами:

- (100, 2023-01-01) → строка 1.
- (100, 2023-01-02) → строка 2.
- (200, 2023-01-01) → строка 3.
- (200, 2023-01-03) → строка 4.

---
#### 2. Поиск

- База использует составной индекс для запросов, где условия включают индексированные столбцы.
- Эффективность зависит от порядка столбцов в индексе и условий в запросе.

**Пример запроса:**
```sql
SELECT * FROM orders
WHERE user_id = 100 AND order_date = '2023-01-02';
```

- База ищет в B-дереве ключ `(100, 2023-01-02)`:  
    1. Находит все записи с `user_id = 100` (первая часть ключа).
    2. Среди них ищет `order_date = 2023-01-02` (вторая часть).
    3. Возвращает строку 2.

План:
```text
Index Scan using idx_user_date on orders
```

#### 3. Сортировка

- Индекс уже упорядочен, поэтому помогает с `ORDER BY` на индексированных столбцах.

Пример:
```sql
SELECT * FROM orders
WHERE user_id = 100
ORDER BY order_date;
```

- Индекс возвращает строки для `user_id = 100` в порядке `order_date`:  
- `(100, 2023-01-01)`, затем `(100, 2023-01-02)`.

#### 4. Частичное использование

- Индекс работает, если запрос использует **префикс** индекса (левую часть столбцов).
- Пример:
```sql
SELECT * FROM orders WHERE user_id = 100;
```

-  Индекс используется, так как `user_id` — первый столбец.
- **Но:**
```sql
SELECT * FROM orders WHERE order_date = '2023-01-02';
```

- Индекс **не используется**, так как `order_date` — второй столбец, а первый (`user_id`) не указан.

---
### Внутреннее устройство (упрощенно)

- **B-дерево**:  
    - Корень: указатели на диапазоны `(user_id, order_date)`.
    - Узлы: более узкие диапазоны.
    - Листья: конкретные ключи `(100, 2023-01-01)` с указателями на строки.
- **Сложность**:  
    - Поиск: `O(log n)`, где `n` — число записей в таблице.
    - Обновление: `O(log n)` при вставке/удалении.

---
### Когда используется составной индекс?

1. **Многостолбцовые условия**:
```sql
WHERE user_id = 100 AND order_date BETWEEN '2023-01-01' AND '2023-01-03';
```

2. **Сортировка по нескольким полям**:
```sql
ORDER BY user_id, order_date;
```

3. **Соединения:**
```sql
SELECT u.name, o.amount
FROM users u
JOIN orders o ON u.id = o.user_id AND o.order_date = '2023-01-02';
```

---
### Преимущества

- Ускоряет запросы с комбинацией столбцов.
- Экономит место по сравнению с отдельными индексами на каждый столбец.
- Поддерживает порядок, уменьшая необходимость сортировки
### Ограничения

- **Порядок важен**: Если запрос не использует префикс индекса, он бесполезен.
- **Размер**: Чем больше столбцов, тем больше места занимает индекс.
- **Обновления**: Как и любой индекс, замедляет `INSERT`, `UPDATE`, `DELETE`.
  
---
### Итог

Составной индекс работает как упорядоченное дерево ключей из нескольких столбцов:
  
- Ускоряет поиск и сортировку по комбинациям (`WHERE`, `ORDER BY`).
- Эффективен, если запросы используют префикс индекса (первые столбцы).
- Порядок столбцов критичен: ставьте наиболее часто фильтруемые столбцы первыми.

-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
