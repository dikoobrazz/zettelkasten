2025022423:08
___
Date: 24-02-2025 | 23:08
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Что такое errgroup.Group и как с ней работать

 **errgroup.Group** из пакета golang.org/x/sync/errgroup. Это популярный инструмент для работы с конкурентностью, который упрощает управление группой горутин, синхронизацию, обработку ошибок и отмену через контекст. 

### Что такое errgroup.Group?

> **errgroup.Group** — это структура из пакета golang.org/x/sync/errgroup, которая объединяет в себе:

1. **Синхронизацию**: Ожидание завершения всех горутин (как **sync.WaitGroup**).
2. **Обработку ошибок**: Возвращает первую ошибку, возникшую в любой из горутин.
3. **Контекст и отмена**: Интеграция с **context.Context** для остановки всех горутин, если одна из них завершилась с ошибкой или контекст был отменен.

Это особенно полезно, когда вы запускаете несколько параллельных задач, связанных общей целью, и хотите:

- Дождаться их завершения.
- Узнать, если что-то пошло не так.
- Остановить все задачи, если одна из них провалилась.

### Как установить?
  
Пакет не входит в стандартную библиотеку, поэтому его нужно установить:
```bash
go get golang.org/x/sync/errgroup
```

### Как работает errgroup.Group?

**Основные методы:**
- **Go(func() error)**: Запускает функцию в новой горутине. Функция должна возвращать **error**.
- **Wait() error**: Блокирует выполнение, пока все горутины не завершатся, и возвращает первую встреченную ошибку (или **nil**, если ошибок нет).
- **WithContext(ctx context.Context)**: Создает **errgroup.Group** с привязанным контекстом, который отменяется при первой ошибке или внешней отмене.

### Пример использования

#### 1. Простой пример: параллельные задачи
```go
package main

import (
    "fmt"
    "golang.org/x/sync/errgroup"
)

func main() {
    var g errgroup.Group

    // Запускаем несколько горутин
    for i := 0; i < 3; i++ {
        i := i // Захват переменной
        g.Go(func() error {
            if i == 1 {
                return fmt.Errorf("ошибка в задаче %d", i)
            }
            fmt.Printf("Задача %d выполнена\n", i)
            return nil
        })
    }

    // Ждем завершения и проверяем ошибку
    if err := g.Wait(); err != nil {
        fmt.Println("Произошла ошибка:", err)
    } else {
        fmt.Println("Все задачи успешно завершены")
    }
}
```

**Вывод** (примерный):
```text
Задача 0 выполнена
Задача 2 выполнена
Произошла ошибка: ошибка в задаче 1
```

**Объяснение**:
- Три горутины запускаются через **g.Go**.
- Вторая горутина (i=1) возвращает ошибку.
- **Wait()** возвращает эту ошибку, как только все горутины завершатся.
  
#### 2. Использование с контекстом
```go
package main

import (
    "context"
    "fmt"
    "golang.org/x/sync/errgroup"
    "time"
)

func main() {
    g, ctx := errgroup.WithContext(context.Background())

    // Задача 1: завершается с ошибкой
    g.Go(func() error {
        time.Sleep(1 * time.Second)
        return fmt.Errorf("ошибка в задаче 1")
    })

    // Задача 2: реагирует на отмену контекста
    g.Go(func() error {
        select {
        case <-ctx.Done():
            return ctx.Err()
        case <-time.After(2 * time.Second):
            fmt.Println("Задача 2 завершена")
            return nil
        }
    })

    // Ждем завершения
    if err := g.Wait(); err != nil {
        fmt.Println("Ошибка:", err)
    }
}
```

**Вывод**:
```text
Ошибка: ошибка в задаче 1
```

**Объяснение**:
- **WithContext** создает группу и контекст.
- Первая горутина возвращает ошибку через 1 секунду, что отменяет контекст (**ctx**).
- Вторая горутина прерывается через **<-ctx.Done()** и возвращает **context.Canceled**.
- **Wait()** возвращает первую ошибку ("ошибка в задаче 1").
  
#### 3. Ограничение параллелизма  

С версии Go 1.23 (или в более ранних версиях экспериментально) **errgroup** поддерживает метод **SetLimit(n int)** для ограничения числа одновременно работающих горутин:
```go
g.SetLimit(2) // Максимум 2 горутины одновременно
```

### Когда использовать `errgroup`?

- Когда нужно выполнить несколько независимых задач параллельно (например, запросы к разным API).
- Если при ошибке в одной задаче нужно остановить остальные.
- Когда требуется простая синхронизация и обработка ошибок без сложных каналов.

### Нюансы

1. **Только первая ошибка**: **Wait()** возвращает только первую ошибку. Если нужно собрать все ошибки, можно использовать сторонние пакеты вроде github.com/hashicorp/go-multierror.
2. **Контекст обязателен для отмены**: Если не использовать **WithContext,** отмена при ошибке не произойдет.
3. **Не заменяет каналы**: **errgroup** не передает данные между горутинами, для этого нужны каналы.
  
### Итог
  
**errgroup.Group** — это удобный инструмент для управления группой горутин с акцентом на обработку ошибок и синхронизацию. Он идеален для задач, где требуется параллелизм с контролем завершения.

-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
