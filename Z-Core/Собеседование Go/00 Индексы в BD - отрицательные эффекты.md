2025030216:47
___
Date: 02-03-2025 | 16:47
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Основные отрицательные эффекты от индексов

Индексы в базах данных ускоряют чтение данных, но имеют отрицательные эффекты, которые могут повлиять на производительность и использование ресурсов.

---
### Основные отрицательные эффекты от индексов

#### 1. Замедление операций записи

- **Что происходит**: Каждое изменение данных в таблице (INSERT, UPDATE, DELETE) требует обновления всех индексов, связанных с изменяемыми столбцами.
- **Почему**: Индексы — это дополнительные структуры (обычно B-деревья), которые нужно поддерживать в актуальном состоянии. Добавление, изменение или удаление строки приводит к пересчету индекса.
- **Пример**:
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email TEXT,
    name TEXT
);
CREATE INDEX idx_email ON users(email);
```

- `INSERT INTO users (email, name) VALUES ('alice@example.com', 'Alice');`
    - Без индекса: просто добавляем строку. 
    - С индексом: добавляем строку + обновляем B-дерево для `email`.
- **Эффект**: В таблице с множеством индексов (например, 5-10) операции записи могут замедлиться в разы.
  
#### 2. Увеличение использования дискового пространства

- **Что происходит**: Индексы — это отдельные структуры, которые хранят копии данных столбцов (или их хэши) плюс ссылки на строки.
- **Почему**: Чем больше индексов и чем шире индексируемые столбцы (например, `TEXT`), тем больше места они занимают.
- **Пример**:  
    - Таблица `users` с 1 миллионом строк, столбец `email` (в среднем 20 байт).
    - Индекс на `email` может занять десятки мегабайт, в зависимости от реализации.
- **Эффект**: На диске может закончиться место, особенно в больших базах с множеством индексов.
  
#### 3. Повышенная нагрузка на память

- **Что происходит**: Индексы загружаются в оперативную память для ускорения запросов, увеличивая её потребление.
- **Почему**: СУБД (например, PostgreSQL, MySQL) кэширует индексы в буферах (buffer pool), и слишком много индексов могут вытеснять другие данные.
- **Пример**:
	- Маленький сервер с 4 ГБ RAM и таблицей с 10 индексами.
    - Большая часть памяти уходит на индексы, а не на данные или запросы.
- **Эффект**: Ухудшение общей производительности из-за частых операций ввода-вывода (I/O).

#### 4. Усложнение планирования запросов

- **Что происходит**: Оптимизатор запросов должен выбирать, использовать индекс или нет, что иногда приводит к ошибкам.
- **Почему**: Слишком много индексов может запутать планировщик, и он выберет неоптимальный план (например, индекс вместо полного сканирования для маленькой таблицы).
- **Пример:**
```sql
SELECT * FROM users WHERE age > 30;
```

- С индексом на `age`: Планировщик может выбрать `Index Scan`, хотя для таблицы с 100 строками `Seq Scan` быстрее.
- **Эффект**: Запросы могут замедлиться из-за неверного выбора индекса.

#### 5. Деградация при низкой селективности

- **Что происходит**: Индексы на столбцах с низкой селективностью (мало уникальных значений) почти бесполезны и только добавляют накладные расходы.
- **Почему**: Если индекс возвращает почти все строки (например, пол: "M" или "F"), то его использование неэффективно.  
- **Пример**:  
    - Индекс на столбце `gender` (значения: "M", "F") в таблице с миллионом строк.
    - `SELECT * FROM users WHERE gender = 'M';` — индекс возвращает 50% строк, что не лучше полного сканирования.
- **Эффект**: Лишние затраты на обслуживание индекса без выигрыша в скорости.

---
### Практические примеры

#### Замедление записи
```sql
CREATE TABLE logs (
    id SERIAL PRIMARY KEY,
    timestamp TIMESTAMP,
    message TEXT
);
CREATE INDEX idx_timestamp ON logs(timestamp);
```

- Без индекса: `INSERT` занимает 1 мс.
- С индексом: `INSERT` занимает 2-3 мс из-за обновления B-дерева.
- При 1000 вставок в секунду разница заметна.
#### Потребление места

- Таблица 10 млн строк, столбец `email` (20 байт в среднем).
- Индекс на `email` может добавить 200-300 МБ к размеру базы.

---
### Как минимизировать эффекты?

1. **Ограничивать количество индексов**:  
    - Создавайте индексы только для часто используемых столбцов `WHERE`, `JOIN`, `ORDER BY`.
2. **Использовать составные индексы**:  
    - Вместо двух индексов на `user_id` и `order_date` — один на (`user_id`, `order_date`).
3. **Удалять неиспользуемые индексы**:  
    - Проверяйте статистику (например, `pg_stat_user_indexes` в PostgreSQL).
4. **Индексы для чтения, а не записи**:  
    - Если таблица активно обновляется, минимизируйте индексы.
5. **Тестировать производительность**:  
    - Используйте `EXPLAIN` для оценки влияния индексов.

---
### Итог

Основные отрицательные эффекты индексов:
- Замедление операций записи (`INSERT`, `UPDATE`, `DELETE`).
- Увеличение дискового пространства.
- Повышенная нагрузка на память.
- Усложнение запросов и неэффективность при низкой селективности.

Они — плата за ускорение чтения. Используйте индексы с умом, балансируя между скоростью запросов и затратами на обслуживание.


-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
