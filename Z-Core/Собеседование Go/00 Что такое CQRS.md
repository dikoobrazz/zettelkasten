2025022501:20
___
Date: 25-02-2025 | 01:20
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Что такое CQRS

**CQRS** (Command Query Responsibility Segregation) — это архитектурный паттерн, который разделяет операции [[00 Запись и чтение в CQRS|чтения данных]] (Query) и [[00 Запись и чтение в CQRS|записи данных]] (Command) на уровне ответственности. Он основан на принципе, что методы, изменяющие состояние системы, и методы, запрашивающие данные, имеют разные требования и могут быть оптимизированы отдельно. Давайте разберем это подробнее.

### Что такое CQRS

В традиционных подходах (например, CRUD) одна и та же модель данных используется как для чтения, так и для записи. CQRS предлагает разделить эти обязанности:

- **Commands (Команды)**: Отвечают за изменение состояния системы (создание, обновление, удаление). Они изменяют данные, но не возвращают их.
- **Queries (Запросы)**: Отвечают за чтение данных. Они только извлекают информацию, не изменяя состояние.

Иными словами, CQRS разделяет "запись" и "чтение" на разные модели, а иногда даже на разные хранилища.

### Зачем нужен CQRS?

1. **Оптимизация производительности**:  
    - Чтение и запись имеют разные нагрузки. Например, чтение может быть частым и требовать быстрого ответа, а запись — редкой, но сложной.
    - Можно использовать разные структуры данных или базы: реляционные для записи, NoSQL или кэш для чтения.
2. **Упрощение модели**:  
    - Модель для записи может быть сложной (с валидацией, бизнес-логикой), а модель для чтения — простой и оптимизированной под запросы.
3. **Масштабируемость**:  
    - Разделение позволяет масштабировать чтение и запись независимо. Например, больше серверов для чтения, если оно доминирует.
4. **Гибкость**:  
    - Легче адаптировать систему под разные требования UI или API (например, денормализованные данные для быстрого отображения).
5. **Поддержка Event Sourcing**:  
    - CQRS часто сочетается с Event Sourcing, где изменения состояния хранятся как последовательность событий, а чтение строится на их основе.

### Как работает CQRS?

1. **Команды**:  
    - Пример: **CreateUser**, **UpdateOrder**, **DeleteProduct**.
    - Команда отправляется в систему, обрабатывается (с валидацией и логикой), изменяет состояние в хранилище для записи.
    - Возвращает только успех/ошибку, а не данные.
2. **Запросы**:  
    - Пример: **GetUserByID**, **ListOrders**.
    - Запрос обращается к отдельной модели или хранилищу, оптимизированному для чтения.
    - Возвращает данные без изменений состояния.
3. **Разделение моделей**:  
    - Для [[00 Запись и чтение в CQRS|записи]]: сложная доменная модель (DDD), нормализованная база.
    - Для [[00 Запись и чтение в CQRS|чтения]]: плоские DTO, денормализованные данные, кэш.

### Пример в Go

Представим простую систему управления пользователями с CQRS.

#### Модель для записи (Command)
```go
package main

import (
    "errors"
    "fmt"
)

// UserWriteModel — модель для записи
type UserWriteModel struct {
    ID    int
    Name  string
    Email string
}

// UserCommandHandler обрабатывает команды
type UserCommandHandler struct {
    repo *UserWriteRepo
}

func (h *UserCommandHandler) CreateUser(name, email string) error {
    if email == "" {
        return errors.New("email обязателен")
    }
    user := UserWriteModel{ID: 1, Name: name, Email: email}
    return h.repo.Save(user)
}

// UserWriteRepo — имитация хранилища для записи
type UserWriteRepo struct {
    users map[int]UserWriteModel
}

func (r *UserWriteRepo) Save(user UserWriteModel) error {
    r.users[user.ID] = user
    return nil
}
```

#### Модель для чтения (Query)
```go
// UserReadModel — упрощенная модель для чтения
type UserReadModel struct {
    ID   int
    Name string
}

// UserQueryHandler обрабатывает запросы
type UserQueryHandler struct {
    repo *UserReadRepo
}

func (h *UserQueryHandler) GetUser(id int) (UserReadModel, error) {
    user, ok := h.repo.Find(id)
    if !ok {
        return UserReadModel{}, errors.New("пользователь не найден")
    }
    return user, nil
}

// UserReadRepo — имитация хранилища для чтения
type UserReadRepo struct {
    users map[int]UserReadModel
}

func (r *UserReadRepo) Find(id int) (UserReadModel, bool) {
    user, ok := r.users[id]
    return user, ok
}

func main() {
    writeRepo := &UserWriteRepo{users: make(map[int]UserWriteModel)}
    readRepo := &UserReadRepo{users: make(map[int]UserReadModel)}
    cmdHandler := &UserCommandHandler{repo: writeRepo}
    queryHandler := &UserQueryHandler{repo: readRepo}

    // Команда: создаем пользователя
    err := cmdHandler.CreateUser("Alice", "alice@example.com")
    if err != nil {
        fmt.Println("Ошибка:", err)
        return
    }
    // В реальной системе здесь бы обновлялось хранилище чтения
    readRepo.users[1] = UserReadModel{ID: 1, Name: "Alice"}

    // Запрос: получаем пользователя
    user, err := queryHandler.GetUser(1)
    if err != nil {
        fmt.Println("Ошибка:", err)
        return
    }
    fmt.Println("Пользователь:", user.Name)
}
```

### Реальный мир

- **Хранилища**: Для записи — PostgreSQL (нормализованная схема), для чтения — Redis или Elasticsearch (денормализованные данные).
- **Синхронизация**: После выполнения команды данные обновляются в модели чтения (асинхронно через очереди или события).
- **Сложность**: В примере синхронизация упрощена, но в продакшене это может быть шина сообщений (Kafka, RabbitMQ).
  
### Преимущества CQRS

- Разделение ответственности упрощает поддержку кода.
- Легче оптимизировать чтение (кэши, индексы) и запись (валидация, логика).
- Подходит для высоконагруженных систем.

### Недостатки

- Увеличивает сложность: два хранилища, синхронизация.
- Возможна несогласованность (eventual consistency) между моделями чтения и записи.
- Требует больше ресурсов на проектирование.

### Когда использовать?

- Сложные системы с разными требованиями к чтению и записи.
- Микросервисы, где сервисы могут быть оптимизированы отдельно.
- В сочетании с Event Sourcing для построения проекций.
  
Для Middle Go Developer CQRS — это шаг к архитектурному мышлению. Если вам интересно, могу показать интеграцию с конкретной базой или шиной сообщений! Что скажете?



-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
- [[00 Запись и чтение в CQRS]]

------
**Links** (Внешние ссылки)
-
