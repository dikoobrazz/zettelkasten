2025030222:26
___
Date: 02-03-2025 | 22:26
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Уровни изоляции в базах данных

> **Уровни изоляции в базах данных** определяют, как транзакции взаимодействуют друг с другом в условиях конкурентного доступа, обеспечивая баланс между **согласованностью данных** и **производительностью**. Они решают проблемы, такие как "грязное чтение", "неповторяемое чтение" и "фантомы", используя блокировки и управление версиями.

---
### Что такое уровни изоляции?

> **Уровни изоляции** — это стандарты, определенные в спецификации SQL (ANSI SQL-92), которые описывают, насколько одна транзакция изолирована от изменений, сделанных другими параллельными транзакциями. Чем выше уровень, тем строже изоляция, но тем больше накладных расходов (блокировки, задержки).

---
### Основные проблемы конкурентности

1. **Грязное чтение (Dirty Read)**:  
    - Транзакция читает незафиксированные (грязные) данные другой транзакции, которые могут быть откатаны.
2. **Неповторяемое чтение (Non-Repeatable Read)**:  
    - Транзакция читает данные, которые другая транзакция изменяет между чтениями в рамках одной транзакции.
3. **Фантомы (Phantom Read)**:  
    - Транзакция видит разные наборы строк при повторных чтениях из-за вставки/удаления другой транзакцией.

---
### Уровни изоляции

#### 1. Read Uncommitted (Чтение незафиксированных данных)

- **Описание**: Транзакция может читать незафиксированные изменения других транзакций.
- **Проблемы**: Возможны все — грязное чтение, неповторяемое чтение, фантомы.
- **Блокировки**: Нет S-блокировок на чтение, только X-блокировки на запись.
- **Пример**:  
    - Т1: `UPDATE users SET balance = 50 WHERE id = 1` (без `COMMIT`).
    - Т2: `SELECT balance FROM users WHERE id = 1` → видит 50.
    - Т1: `ROLLBACK` → Т2 прочитала "грязные" данные.
- **Когда использовать**: Редко, для некритичных данных, где скорость важнее согласованности (например, статистика).
#### 2. Read Committed (Чтение зафиксированных данных)

- **Описание**: Транзакция видит только зафиксированные данные на момент чтения.
- **Проблемы**: Нет грязного чтения, но возможны неповторяемое чтение и фантомы.
- **Блокировки**: S-блокировки на чтение снимаются сразу после операции, X-блокировки до конца транзакции.
- **Пример**:  
    - Т1: `BEGIN; UPDATE users SET balance = 100 WHERE id = 1;`
    - Т2: `SELECT balance FROM users WHERE id = 1` → видит старое значение 
	    (до `COMMIT` Т1).
    - Т1: `COMMIT`.
    - Т2: `SELECT balance FROM users WHERE id = 1` → видит 100 (неповторяемое чтение).
- **Когда использовать**: По умолчанию в большинстве СУБД (PostgreSQL, MySQL), подходит для большинства приложений.
#### 3. Repeatable Read (Повторяемое чтение)

- **Описание**: Гарантирует, что данные, прочитанные в транзакции, не изменятся до её конца.
- **Проблемы**: Нет грязного и неповторяемого чтения, но возможны фантомы.
- **Блокировки**: S-блокировки держатся до конца транзакции, X-блокировки тоже.
- **Реализация**: В PostgreSQL — через MVCC (многバージонное управление конкурентностью), а не строгие блокировки.
- **Пример**:  
    - Т1: `BEGIN; SELECT balance FROM users WHERE id = 1;` → 50.
    - Т2: `UPDATE users SET balance = 100 WHERE id = 1;` → ждет Т1.
    - Т1: `SELECT balance FROM users WHERE id = 1;` → всё еще 50.
    - Т1: `COMMIT`.
- **Когда использовать**: Когда нужно стабильное чтение данных (например, отчеты).
#### 4. Serializable (Сериализуемый)

- **Описание**: Полная изоляция — транзакции выполняются так, как если бы они шли последовательно, без пересечений
- **Проблемы**: Нет никаких (грязное, неповторяемое, фантомы исключены).
- **Блокировки**: Максимальные, включая диапазонные (range locks), или MVCC с проверкой конфликтов.
- **Пример**:  
    - Т1: `BEGIN; SELECT * FROM users WHERE age > 30;` → 2 строки.
    - Т2: `INSERT INTO users (age) VALUES (35);` → ждет или откатывается.
    - Т1: `SELECT * FROM users WHERE age > 30;` → те же 2 строки (нет фантомов).
    - Т1: `COMMIT`.
- **Когда использовать**: Критические операции, где согласованность важнее скорости (финансы, сложная бизнес-логика).

---
### Сравнение

|Уровень|Грязное чтение|Неповторяемое чтение|Фантомы|Производительность|
|---|---|---|---|---|
|Read Uncommitted|Да|Да|Да|Высокая|
|Read Committed|Нет|Да|Да|Хорошая|
|Repeatable Read|Нет|Нет|Да|Средняя|
|Serializable|Нет|Нет|Нет|Низкая|

---
### Как работают в PostgreSQL?

PostgreSQL использует **MVCC** (Multiversion Concurrency Control):

- Вместо строгих блокировок создаются версии данных.
- Каждая транзакция видит "снимок" базы на момент начала (Read Committed) или стабильный снимок (Repeatable Read, Serializable).
- Блокировки применяются только для записи или при явных командах (FOR UPDATE).
#### Установка уровня
```sql
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
BEGIN;
-- запросы
COMMIT;
```

---
### Пример в Go
```go
package main

import (
    "database/sql"
    "fmt"
    _ "github.com/lib/pq"
)

func main() {
    db, err := sql.Open("postgres", "user=pguser dbname=test sslmode=disable")
    if err != nil {
        fmt.Println(err)
        return
    }
    defer db.Close()

    // Транзакция с Repeatable Read
    tx, err := db.BeginTx(nil, &sql.TxOptions{Isolation: sql.LevelRepeatableRead})
    if err != nil {
        fmt.Println(err)
        return
    }
    defer tx.Rollback()

    var balance int
    err = tx.QueryRow("SELECT balance FROM users WHERE id = 1").Scan(&balance)
    fmt.Println("Баланс:", balance)

    // Другая транзакция изменяет balance, но мы этого не увидим
    time.Sleep(2 * time.Second) // Имитация параллельной работы
    err = tx.QueryRow("SELECT balance FROM users WHERE id = 1").Scan(&balance)
    fmt.Println("Баланс (повторно):", balance)

    tx.Commit()
}
```

---
### Когда какой уровень использовать?

- **Read Uncommitted**: Почти не используется, только для грязных черновых данных.
- **Read Committed**: Стандарт для большинства приложений (быстро, достаточно согласованно).
- **Repeatable Read**: Когда нужно стабильное чтение без изменений (отчеты, аналитика).
- **Serializable**: Критические операции, где любые аномалии недопустимы (банки, сложные транзакции).

---
### Итог

Уровни изоляции:

- Управляют видимостью данных между транзакциями.
- Решают проблемы конкурентности (грязное чтение, фантомы).
- Балансируют между согласованностью и производительностью.

В PostgreSQL чаще всего хватает Read Committed, но выбор зависит от задачи.

-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
