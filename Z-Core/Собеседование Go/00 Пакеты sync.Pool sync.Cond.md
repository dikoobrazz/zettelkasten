2025030316:03
___
Date: 03-03-2025 | 16:03
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## `sync.Pool` и `sync.Connd`. Что это такое, как работают

### 1. [[00 Пакет sync.Pool - подробно|sync.Pool]]
#### Что это?

- `sync.Pool` — это конкурентно-безопасный пул объектов, который позволяет временно хранить и повторно использовать экземпляры объектов, минимизируя аллокации памяти и нагрузку на сборщик мусора (GC).
- Это не кэш с долгосрочным хранением, а временный буфер для повторного использования.
#### Как работает?
  
- **Структура**:  
    - Пул содержит набор объектов, которые можно "брать" (Get) и "возвращать" (Put).
    - Поле `New` (опциональная функция) создает новый объект, если пул пуст.
- **Механизм**:  
    - `Get()` извлекает объект из пула или вызывает `New`, если пула нет.
    - `Put(x)` возвращает объект в пул.
    - GC может очистить пул (объекты не гарантированно сохраняются между вызовами).
- **Конкурентность**: Встроенная защита от одновременного доступа.
##### Пример использования
```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    // Создаем пул с функцией New
    pool := sync.Pool{
        New: func() interface{} {
            fmt.Println("Создан новый буфер")
            return make([]byte, 1024)
        },
    }

    // Берем объект
    buf1 := pool.Get().([]byte)
    fmt.Println("buf1 длина:", len(buf1))
    pool.Put(buf1) // Возвращаем

    // Берем снова
    buf2 := pool.Get().([]byte)
    fmt.Println("buf2 длина:", len(buf2)) // Переиспользован buf1
    pool.Put(buf2)

    // Создаем нагрузку для GC
    for i := 0; i < 1000000; i++ {
        _ = make([]byte, 1024)
    }

    // Проверяем после GC
    buf3 := pool.Get().([]byte)
    fmt.Println("buf3 длина:", len(buf3)) // Может быть новым
}
```

**Вывод** (примерный):
```text
Создан новый буфер
buf1 длина: 1024
buf2 длина: 1024
Создан новый буфер
buf3 длина: 1024
```
#### Как работает внутри?

- Пул делится на локальные подпулы для каждого P (процессора в модели Go scheduler’а).
- Каждый подпул имеет очередь объектов.
- Если пул пуст, вызывается `New`.
- GC периодически очищает пулы (между сборками), поэтому содержимое не гарантировано.

---
#### Best Practices

1. **Используйте для временных объектов**:  
    - Идеально для буферов, временных структур (например, `[]byte`, `strings.Builder`).
    - Не используйте для долгосрочного хранения (это не кэш).
2. **Задавайте New**:  
    - Без `New` `Get()` вернет `nil`, что может привести к панике при приведении типа.
```go
pool := sync.Pool{
    New: func() interface{} { return &MyStruct{} },
}
```

3. **Очищайте объекты перед Put**:  
	- Объекты в пуле могут содержать старые данные, поэтому сбрасывайте их состояние.
```go
buf := pool.Get().([]byte)
buf = buf[:0] // Очищаем перед использованием
```

4. **Не зависьте от содержимого**:  
    - GC может удалить объекты, поэтому не рассчитывайте, что `Get()` вернет то, что вы положили.

---
#### Подводные камни

1. **Непредсказуемость после GC**:  
    - После сборки мусора пул может опустеть, и `Get()` начнет создавать новые объекты.
    - Решение: Тестируйте с нагрузкой и GC.
2. **Утечки памяти**:  
    - Если положить в пул большие объекты и не использовать их, они останутся в памяти до GC.
    - Решение: Храните только то, что действительно переиспользуется.
3. **Типобезопасность**:  
    - `Get()` возвращает `interface{}`, требуется явное приведение типа, что может паниковать.
    - Решение: Проверяйте тип или гарантируйте однотипность.
```go
v := pool.Get()
buf, ok := v.([]byte)
if !ok {
    panic("Неверный тип в пуле")
}
```

4. **Не для всех случаев**:  
    - Если создание объекта дешево (например, int), пул избыточен.
#### Когда использовать?

- Высоконагруженные приложения с частыми аллокациями (буферы, парсеры).
- Снижение давления на GC (например, в веб-серверах).

---
### 2. sync.Cond
#### Что это?

- `sync.Cond` — условная переменная, которая позволяет горутинам ждать определенного условия и получать сигнал о его выполнении.
- Это примитив для синхронизации по событиям, работающий в связке с мьютексом.
#### Как работает?

- **Структура**:  
    - Связана с `Locker` (обычно `sync.Mutex`).
    - Хранит очередь ждущих горутин.
- **Методы**:  
    - `Wait()`: Блокирует горутину, пока не придет сигнал, временно освобождая мьютекс.
    - `Signal()`: Будит одну ждущую горутину.
    - `Broadcast()`: Будит все ждущие горутины
- **Механизм**:  
    - Вызов `Wait()` блокирует, пока другая горутина не вызовет `Signal()` или `Broadcast()`
#### Пример использования
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, cond *sync.Cond, ready *bool, wg *sync.WaitGroup) {
    defer wg.Done()
    cond.L.Lock()
    fmt.Printf("Работник %d ждет\n", id)
    for !*ready {
        cond.Wait() // Ждет сигнала
    }
    fmt.Printf("Работник %d разбужен\n", id)
    cond.L.Unlock()
}

func main() {
    var mu sync.Mutex
    cond := sync.NewCond(&mu)
    ready := false
    var wg sync.WaitGroup

    // Запускаем 3 работников
    for i := 1; i <= 3; i++ {
        wg.Add(1)
        go worker(i, cond, &ready, &wg)
    }

    time.Sleep(1 * time.Second) // Даем им начать ждать
    mu.Lock()
    ready = true
    fmt.Println("Отправляем сигнал всем")
    cond.Broadcast() // Будим всех
    mu.Unlock()

    wg.Wait()
}
```

**Вывод**:
```go
Работник 1 ждет
Работник 2 ждет
Работник 3 ждет
Отправляем сигнал всем
Работник 1 разбужен
Работник 2 разбужен
Работник 3 разбужен
```

#### Как работает внутри?

- `Cond` использует мьютекс (*L*) для защиты условия.
- `Wait()` добавляет горутину в очередь и освобождает мьютекс, чтобы другая могла его захватить.
- `Signal()` или `Broadcast()` будят горутины, возвращая им управление с заблокированным мьютексом.
  
---
#### Best Practices
  
1. **Всегда используйте с мьютексом**:  
    - `Cond` требует `Locker`, иначе будет паника.

```go
cond := sync.NewCond(&sync.Mutex{})
```

2. **Проверяйте условие в цикле**:  
	- `Wait()` может проснуться случайно (spurious wakeup), проверяйте условие явно.

```go
for !condition {
    cond.Wait()
}
```

- **Используйте `Broadcast` с умом**:  
    - Если нужно разбудить всех (например, завершение процесса), а не одного.
- **Минимизируйте блокировку**:  
    - Держите мьютекс заблокированным только для проверки условия и сигнала.

---
#### Подводные камни

1. **Spurious Wakeups**:  
    - Горутина может проснуться без сигнала, поэтому всегда проверяйте условие.
    - Решение: Цикл `for`.
2. **Забытый Unlock**:  
    - Если не разблокировать мьютекс после `Wait()`, другие горутины застрянут.
    - Решение: Закрывайте критическую секцию явно.
3. **Deadlock**:  
    - Если все горутины ждут, а никто не сигнализирует, программа зависнет.
    - Решение: Гарантируйте вызов `Signal()` или `Broadcast()`.
4. **Ограниченная применимость**:  
    - Каналы часто удобнее для простых задач синхронизации.
#### Когда использовать?

- Ожидание события (например, готовности данных).
- Координация по условиям (например, все воркеры ждут старта).

---
### Итог

- **[[00 Пакет sync.Pool - подробно|sync.Pool]]**:  
    - Временный пул для повторного использования объектов.
    - Работа: `Get`/`Put`, с опциональным `New`.
    - Лучше для: буферов, снижения аллокаций.
    - Подводные камни: GC-очистка, типобезопасность.
- **sync.Cond**:  
    - Условная переменная для ожидания событий.
    - Работа: `Wait`, `Signal`, `Broadcast` с мьютексом.
    - Лучше для: сложной синхронизации по условиям.
    - Подводные камни: spurious wakeups, deadlocks.

**Best Practice**: Используйте `Pool` для оптимизации памяти, `Cond` для событийной синхронизации, но предпочитайте каналы там, где они проще


-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
- [[00 Пакет sync.Pool - подробно]]

------
**Links** (Внешние ссылки)
-
