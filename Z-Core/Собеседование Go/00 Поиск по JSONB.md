2025030421:47
___
Date: 04-03-2025 | 21:47
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Можно ли эффективно искать по jsonb

> Да, в PostgreSQL можно **эффективно искать по JSONB**, благодаря его бинарному формату и поддержке индексов, таких как **GIN** (Generalized Inverted Index). Это делает JSONB подходящим для запросов по ключам, значениям и вложенным структурам, особенно в больших объемах данных

---
### Почему поиск по JSONB эффективен?

1. **Бинарный формат**:
    - `JSONB` хранит данные в разобранном виде, а не как текст (в отличие от `JSON`), что ускоряет доступ к элементам без повторного парсинга.
2. **Поддержка индексов**:
    - **GIN**: Инвертированный индекс, оптимизированный для поиска по ключам, значениям и подструктурам.
    - Позволяет быстро находить записи, соответствующие условиям (например, `@>` или `?`).
3. **Операторы**:
    - `@>`: Проверяет, содержит ли JSONB заданный объект.
    - `->`: Извлекает элемент по ключу/индексу.
    - `?`: Проверяет наличие ключа.

---
### Как эффективно искать?
#### Без индекса

- Поиск по `JSONB` без индекса требует полного сканирования (`Seq Scan`), что медленно для больших таблиц.
#### С индексом

- Создание GIN-инкса ускоряет запросы, особенно для условий с операторами `@>,` `?`, `?|`, `?&`

---
### Пример в PostgreSQL

##### Создание таблицы и данных
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    data JSONB
);

INSERT INTO users (data) VALUES
    ('{"name": "Alice", "age": 30, "city": "New York"}'),
    ('{"name": "Bob", "age": 25, "city": "San Francisco"}'),
    ('{"name": "Charlie", "age": 35, "city": "New York"}');
```
##### Запрос без индекса
```sql
SELECT * FROM users WHERE data @> '{"city": "New York"}';
```

**План** (EXPLAIN):
```text
Seq Scan on users  (cost=0.00..1.03 rows=1 width=36)
  Filter: (data @> '{"city": "New York"}'::jsonb)
```

**Комментарий**: Полное сканирование таблицы, медленно для миллионов записей.

##### Создание GIN-индекса
```sql
CREATE INDEX idx_users_data ON users USING GIN (data);
```
##### Запрос с индексом
```sql
SELECT * FROM users WHERE data @> '{"city": "New York"}';
```

**План** (EXPLAIN):
```text
Bitmap Heap Scan on users  (cost=8.00..12.01 rows=1 width=36)
  Recheck Cond: (data @> '{"city": "New York"}'::jsonb)
  ->  Bitmap Index Scan on idx_users_data  (cost=0.00..8.00 rows=1 width=0)
```

**Комментарий**: Используется индекс, поиск быстрее за счет Bitmap Index Scan.
##### Поиск по ключу
```sql
SELECT data->>'name' FROM users WHERE data->>'city' = 'New York';
```

**Комментарий**: Без индекса по выражению (`data->>'city'`) — `Seq Scan`. Для ускорения нужен индекс на выражение:
```sql
CREATE INDEX idx_users_city ON users ((data->>'city'));
```

---
### Тонкости эффективного поиска

1. **Тип индекса**:
    - **GIN**: Лучше для поиска по структуре (`@>`, `?`).
    - **B-tree**: Для конкретных выражений (`data->>'key'`).
2. **Ограничения**:
    - GIN не индексирует порядок элементов в массивах или точное равенство значений без выражения.
    - Размер индекса может быть большим при сложных JSONB.
3. **Оптимизация**:
    - Используйте `EXPLAIN ANALYZE` для проверки плана запроса.
    - Для частых запросов по конкретным полям создавайте индексы на выражения:
```sql
CREATE INDEX idx_users_age ON users ((data->>'age'::int));
```

4. **Производительность**:
    - Без индекса: *O(n)* — линейное сканирование.
    - С GIN: *O(log ⁡n)* или лучше для поиска по ключам/значениям.

---
### Коротко

- **Можно ли эффективно искать?**: Да, с GIN-индексом поиск по `JSONB` становится быстрым.
- **Как?**: Используйте операторы (`@>`, `?`) и индексы (GIN для структуры, B-tree для выражений).
- **Когда эффективно?**: При больших данных и правильной индексации.

-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
