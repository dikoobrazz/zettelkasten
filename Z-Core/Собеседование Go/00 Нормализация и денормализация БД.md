2025022501:40
___
Date: 25-02-2025 | 01:40
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Нормализация и денормализация БД

> **Нормализация** и **денормализация** — это два противоположных подхода к проектированию структуры баз данных, которые решают разные задачи в зависимости от требований к производительности, целостности данных и сценариев использования. Давайте разберем их подробно, с примерами и контекстом продакшена.

---
### Что такое нормализация?
#### Определение

> **Нормализация** — это процесс организации данных в реляционной базе данных (например, PostgreSQL, MySQL) для устранения избыточности и обеспечения целостности данных. Она основана на правилах, называемых **нормальными формами** (1NF, 2NF, 3NF и т.д.), которые уменьшают дублирование и зависимости в таблицах.

#### Основные принципы

1. **Устранение дублирования**: Каждое значение хранится только в одном месте.
2. **Логическое разделение**: Данные разбиваются на связанные таблицы с использованием ключей (первичных и внешних).
3. **Целостность**: Обеспечивается через ограничения (foreign keys, unique constraints).

#### Пример нормализации

Допустим, у нас есть таблица заказов:

|OrderID|CustomerName|CustomerAddress|ProductName|ProductPrice|
|---|---|---|---|---|
|1|Alice|123 Main St|Laptop|1000|
|2|Bob|456 Oak St|Phone|500|
|3|Alice|123 Main St|Mouse|20|

#### Проблемы:
- Дублирование **CustomerName** и **CustomerAddress** для Alice.
- Если адрес Alice изменится, нужно обновить его везде — риск несогласованности.
  
#### Нормализация до 3NF:

1. **1NF**: Убираем повторяющиеся группы (уже соблюдено).
2. **2NF**: Выносим данные о клиентах в отдельную таблицу, так как **CustomerName** и **CustomerAddress** не зависят от **Product**.
3. **3NF**: Выносим продукты в отдельную таблицу, так как **ProductPrice** зависит только от **ProductName**.

Результат — три таблицы:
**Customers**

| CustomerID | Name  | Address     |
| ---------- | ----- | ----------- |
| 1          | Alice | 123 Main St |
| 2          | Bob   | 456 Oak St  |
|            |       |             |

**Products**

|ProductID|Name|Price|
|---|---|---|
|1|Laptop|1000|
|2|Phone|500|
|3|Mouse|20|

**Orders**

|OrderID|CustomerID|ProductID|
|---|---|---|
|1|1|1|
|2|2|2|
|3|1|3|

#### Зачем нужна нормализация?

- **Целостность данных**: Изменение адреса Alice обновляется в одном месте.
- **Экономия места**: Нет дублирования.
- **Поддержка транзакций**: Нормализованные базы идеальны для операций записи (INSERT, UPDATE, DELETE) с соблюдением ACID.

#### Когда применяется?

- **OLTP-системы** (Online Transaction Processing): Банки, CRM, системы заказов, где важны частые обновления и целостность.
- **Сложная бизнес-логика**: Когда данные связаны и должны быть консистентны.
  
---
### Что такое денормализация?

#### Определение

> **Денормализация** — это процесс сознательного добавления избыточности в базу данных, объединения таблиц или упрощения структуры для ускорения операций чтения. Она жертвует целостностью ради производительности.

#### Основные принципы

1. **Добавление избыточности**: Данные дублируются для быстрого доступа.
2. **Упрощение запросов**: Меньше JOIN-ов или вообще их отсутствие.
3. **Оптимизация под чтение**: Данные хранятся в формате, удобном для запросов.
4. 
#### Пример денормализации

Вернемся к нормализованным таблицам. Если нам часто нужно получать заказы с именами клиентов и продуктов, запрос будет выглядеть так:
```sql
SELECT o.OrderID, c.Name, p.Name, p.Price
FROM Orders o
JOIN Customers c ON o.CustomerID = c.CustomerID
JOIN Products p ON o.ProductID = p.ProductID;
```

Это работает, но при миллионах записей JOIN-ы становятся дорогими.

**Денормализованная таблица:**

|OrderID|CustomerName|ProductName|ProductPrice|
|---|---|---|---|
|1|Alice|Laptop|1000|
|2|Bob|Phone|500|
|3|Alice|Mouse|20|

Теперь запрос:
```sql
SELECT OrderID, CustomerName, ProductName, ProductPrice FROM Orders;
```

#### Зачем нужна денормализация?

- **Скорость чтения**: Уменьшает нагрузку на базу при частых запросах.
- **Простота**: Упрощает код приложения и запросы.
- **Поддержка аналитики**: Удобно для OLAP-систем (Online Analytical Processing).

#### Когда применяется?

- **Чтение-доминантные системы**: Dashboards, витрины данных, отчеты.
- **Высокая нагрузка**: Когда JOIN-ы тормозят производительность.
- **Кэширование**: Как промежуточный слой для быстрого доступа.

---
### Как это происходит в продакшене?

#### Нормализация в продакшене

1. **Проектирование**: Архитектор базы создает нормализованную схему (ER-диаграммы, 3NF).
2. **Реализация**:  
    - Создаются таблицы с первичными и внешними ключами.
    - Используются транзакции для операций записи (например, через database/sql в Go).
3. **Пример в Go**:
```go
func createOrder(db *sql.DB, customerID, productID int) error {
    tx, err := db.Begin()
    if err != nil {
        return err
    }
    defer tx.Rollback()
    _, err = tx.Exec("INSERT INTO Orders (CustomerID, ProductID) VALUES ($1, $2)", customerID, productID)
    if err != nil {
        return err
    }
    return tx.Commit()
}
```

4. **Поддержание**: Индексы на внешние ключи, миграции для изменения схемы.
  
#### Денормализация в продакшене

1. **Источники данных**: Денормализованные данные обычно строятся из нормализованных.
2. **Механизмы**:  
    - **Материализованные представления**: В PostgreSQL создаются представления, которые периодически обновляются.
    - **ETL-процессы**: Extract, Transform, Load — данные извлекаются, преобразуются и загружаются в денормализованное хранилище (например, через Airflow).
    - **События (CQRS)**: Как в примере с CQRS, после записи в нормализованную базу событие обновляет денормализованный кэш (Redis, Elasticsearch).
3. **Пример в Go с Redis**:
```go
func updateReadStore(rdb *redis.Client, orderID int, customerName, productName string, price int) error {
    data := map[string]interface{}{
        "OrderID":      orderID,
        "CustomerName": customerName,
        "ProductName":  productName,
        "Price":        price,
    }
    jsonData, _ := json.Marshal(data)
    return rdb.Set(context.Background(), fmt.Sprintf("order:%d", orderID), jsonData, 0).Err()
}
```

4. **Обновление**:  
    - **Асинхронно**: Через очереди (Kafka, RabbitMQ) или CDC (Change Data Capture, например, Debezium).
    - **Периодически**: Cron-задания для пересчета данных.
5. **Пример сценария**:  
    - Нормализованная база (PostgreSQL) хранит заказы.
    - После записи заказа публикуется событие в Kafka.
    - Сервис-обработчик обновляет Elasticsearch с денормализованными данными для поиска.

#### Типичный продакшен-флоу

- **Write Store**: PostgreSQL (нормализованная схема для транзакций).
- **Read Store**: Elasticsearch (денормализованные данные для поиска) + Redis (кэш для горячих данных).
- **Синхронизация**: Kafka как шина сообщений, Go-сервисы слушают события и обновляют read store.

---
### Зачем это нужно в продакшене?

- **Нормализация**:  
    - Гарантирует целостность при записи.
    - Упрощает поддержку и расширение системы.
    - Подходит для систем с частыми обновлениями
- **Денормализация**:  
    - Ускоряет чтение в высоконагруженных системах.
    - Упрощает аналитику и отчеты.
    - Поддерживает быстрые UI-запросы.

---
### Проблемы и компромиссы

- **Нормализация**:  
    - JOIN-ы замедляют чтение при больших объемах данных.
    - Сложнее масштабировать для аналитики.
- **Денормализация**:  
    - Избыточность увеличивает объем хранилища.
    - Требует синхронизации, что добавляет сложность (eventual consistency).

---
### Итог

В продакшене нормализация используется для надежной записи (OLTP), а денормализация — для быстрого чтения (OLAP или кэши). Они часто сочетаются: данные пишутся в нормализованную базу, а затем асинхронно денормализуются в отдельное хранилище через события или ETL. В Go это реализуется через работу с **database/sql**, брокерами сообщений и кэшами.




-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
