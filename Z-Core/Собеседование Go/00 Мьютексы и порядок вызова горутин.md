2025030418:09
___
Date: 04-03-2025 | 18:09
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Гарантируют ли мьютексы какой-то порядок вызова горутин?

> Нет, мьютексы в Go (`sync.Mutex` и `sync.RWMutex`) не гарантируют какого-либо определенного порядка вызова горутин, ожидающих разблокировки. Порядок, в котором горутины получат доступ к ресурсу после `Unlock()`, зависит от планировщика Go (scheduler) и не является детерминированным.

---
### Почему порядок не гарантируется?

1. **Поведение мьютекса**:
    - `sync.Mutex` обеспечивает **взаимное исключение**: только одна горутина может захватить мьютекс в любой момент времени.
    - Когда мьютекс разблокируется (`Unlock()`), одна из ожидающих горутин захватывает его, но **какая именно** определяется планировщиком.
2. **Планировщик Go**:
    - Управляет горутинами в рамках потоков ОС (модель M:N).
    - Использует внутреннюю очередь готовых горутин (`runnable`), но порядок выбора из этой очереди не фиксирован (примерно FIFO, но с оговорками).
    - Зависит от факторов: состояние системы, приоритеты, тайминг.
3. **Отсутствие спецификации**:
    - Документация Go не обещает конкретного порядка (например, "первый пришел — первый ушел"). Это оставлено на усмотрение реализации runtime.
##### Пример кода с комментариями
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, mu *sync.Mutex, wg *sync.WaitGroup) {
    defer wg.Done()
    fmt.Printf("Горутина %d ожидает мьютекс\n", id)
    mu.Lock() // горутина блокируется, ожидая разблокировки мьютекса
    fmt.Printf("Горутина %d захватила мьютекс\n", id)
    time.Sleep(100 * time.Millisecond) // имитация работы
    mu.Unlock() // разблокируем мьютекс
}

func main() {
    var mu sync.Mutex // создаем мьютекс
    var wg sync.WaitGroup

    mu.Lock() // main захватывает мьютекс изначально

    // запускаем 3 горутины, которые будут ждать разблокировки
    for i := 1; i <= 3; i++ {
        wg.Add(1)
        go worker(i, &mu, &wg)
    }

    time.Sleep(100 * time.Millisecond) // даем горутинам встать в очередь
    fmt.Println("main разблокирует мьютекс")
    mu.Unlock() // освобождаем мьютекс, одна из горутин его захватит

    wg.Wait() // ждем завершения всех горутин
    fmt.Println("Все горутины завершились")
}
```

**Вывод** (примерный, порядок случайный):

```text
Горутина 1 ожидает мьютекс
Горутина 2 ожидает мьютекс
Горутина 3 ожидает мьютекс
main разблокирует мьютекс
Горутина 2 захватила мьютекс
Горутина 1 захватила мьютекс
Горутина 3 захватила мьютекс
Все горутины завершились
```
#### Комментарии к коду

- **Ожидание**: Все три горутины блокируются на `mu.Lock()`, так как мьютекс изначально захвачен в `main`.
- **Разблокировка**: После `mu.Unlock()` в `main` одна из горутин (например, 2) захватывает мьютекс.
- **Порядок**: Не гарантируется, что горутина 1 выполнится первой, даже если она запустилась раньше. Это решает планировщик.

---
### Коротко: Гарантирует ли порядок?

- **Нет**: Мьютексы гарантируют только исключительный доступ, но не порядок выполнения ожидающих горутин.
- **Кто решает?**: Планировщик Go выбирает следующую горутину случайным образом (в рамках внутренней логики очереди).
#### Как добиться порядка?

- Используйте **каналы** с явной очередью или **sync.Cond** с дополнительной логикой, если порядок важен.
- Пример с каналом:

```go
ch := make(chan int, 3) // буферизированный канал как очередь
```

-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
