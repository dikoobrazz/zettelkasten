2025030715:46
___
Date: 07-03-2025 | 15:46
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## **Партиции (partitions)** в Apache Kafka

> **Партиции (partitions)** в Apache Kafka — это ключевой механизм, обеспечивающий масштабируемость, параллелизм и высокую пропускную способность системы. Они являются основой того, как Kafka распределяет и обрабатывает большие объемы данных.

---
### Что такое партиции?

> **Определение**: Партиция — это логическое разделение топика в Kafka. Каждый топик делится на одну или несколько партиций, которые представляют собой упорядоченные, неизменяемые последовательности сообщений (лог). Каждая партиция хранится на одном из брокеров Kafka и может быть реплицирована для отказоустойчивости.

**Пример структуры**:

- Топик `orders` с 3 партициями:
    - Partition 0: [msg1, msg2, msg3]
    - Partition 1: [msg4, msg5]
    - Partition 2: [msg6, msg7, msg8]

---
### Зачем нужны партиции?

#### 1. Масштабируемость

- **Суть**: Партиции позволяют распределять данные топика между несколькими брокерами в кластере Kafka.
- **Как работает**: Если у вас 3 брокера и топик с 6 партициями, каждая партиция может быть размещена на отдельном брокере (или распределена равномерно). Это увеличивает объем данных, который Kafka может обработать.
- **Пример**: Один брокер может записывать 50к сообщений/с. С 3 брокерами и 3 партициями — уже 150к/с.

**Практика**: Для 100к сообщений/с (как в предыдущем вопросе) создайте топик с 10+ партициями и разверните кластер из 3-5 брокеров.
#### 2. Параллелизм

- **Суть**: Партиции позволяют producer'ам и consumer'ам работать параллельно.
- **Producer**: Сообщения распределяются по партициям (например, по ключу или round-robin), что ускоряет отправку.
- **Consumer**: В consumer group каждая партиция обрабатывается отдельным consumer'ом, что обеспечивает параллельную обработку.
- **Пример**: Топик с 4 партициями и группа из 4 consumer'ов — каждый consumer читает свою партицию одновременно.

**Пример в Go**:
```go
// Producer
writer := kafka.NewWriter(kafka.WriterConfig{
    Brokers:  []string{"localhost:9092"},
    Topic:    "orders",
    Balancer: &kafka.RoundRobin{}, // Распределяет по партициям
})
writer.WriteMessages(context.Background(),
    kafka.Message{Key: []byte("key1"), Value: []byte("Order 1")},
    kafka.Message{Key: []byte("key2"), Value: []byte("Order 2")},
)

// Consumer Group
reader := kafka.NewReader(kafka.ReaderConfig{
    Brokers: []string{"localhost:9092"},
    Topic:   "orders",
    GroupID: "order-group", // До 4 consumer'ов для 4 партиций
})
msg, _ := reader.ReadMessage(context.Background())
println(string(msg.Value))
```

#### 3. Упорядоченность сообщений

- **Суть**: Kafka гарантирует порядок сообщений только внутри одной партиции. Если вам нужен порядок (например, все события одного пользователя), отправляйте их в одну партицию по ключу.
- **Как работает**: Сообщения с одинаковым ключом (например, user123) всегда попадают в одну и ту же партицию.
- **Пример**: Все заказы пользователя user123 будут в Partition 1, сохраняя последовательность.

**Пример с ключом**:
```go
writer.WriteMessages(context.Background(),
    kafka.Message{Key: []byte("user123"), Value: []byte("Order 1")},
    kafka.Message{Key: []byte("user123"), Value: []byte("Order 2")},
) // Оба в одной партиции
```

#### 4. Отказоустойчивость

- **Суть**: Партиции могут быть реплицированы (replication factor) на разные брокеры. Если один брокер упадет, другой с репликой возьмет на себя работу.
- **Как работает**: При replication.factor=3 каждая партиция имеет 3 копии на разных брокерах.
- **Пример**: Partition 0 хранится на брокерах 1, 2, 3. Если брокер 1 упадет, Partition 0 продолжит работу на брокерах 2 или 3.

**Создание топика**:
```bash
kafka-topics.sh --create --topic orders --partitions 4 --replication-factor 3 
--bootstrap-server localhost:9092
```

#### 5. Балансировка нагрузки

- **Суть**: Партиции распределяют нагрузку между брокерами и consumer'ами, предотвращая перегрузку одного узла.
- **Пример**: 100к сообщений/с на топик с 10 партициями = ~10к сообщений/с на партицию, что легче обработать.

---
### Как партиции работают на практике?

1. **Producer**:
    - Использует `Balancer` (например, `Hash` или `RoundRobin`) для выбора партиции.
    - Ключ (`Key`) хэшируется, чтобы определить партицию:

```go
Balancer: &kafka.Hash{} // По ключу
```

2. **Broker**:
    - Каждая партиция — это файл на диске (лог), куда пишутся сообщения.
    - Лидер партиции принимает записи, реплики синхронизируются.
3. **Consumer**:
    - В группе consumer'ов Kafka автоматически назначает партиции (rebalancing).
    - Один consumer не может читать больше партиций, чем их есть в группе.

**Ограничение**: Количество consumer'ов в группе не может превышать число партиций (иначе лишние будут простаивать).

---
### Зачем это нужно в микросервисах?

- **Масштабирование producer'ов**: `OrderService` отправляет 100к заказов/с, распределяя их по 10 партициям.
- **Параллельная обработка**: `NotificationService` и `InventoryService` читают из разных партиций одновременно.
- **Упорядоченность**: Все события одного заказа обрабатываются в строгом порядке в одной партиции.

**Пример сценария**:

- Топик `orders` с 10 партициями.
- `OrderService` пишет заказы.
- Группа consumer'ов (`NotificationService`) с 10 экземплярами обрабатывает их параллельно.

---
### Практические советы

1. **Выбор числа партиций**:
    - Начните с 10-50 для высоконагруженных топиков.
    - Учитывайте число брокеров и consumer'ов (например, 10 партиций = до 10 consumer'ов).
    - Увеличивайте позже с помощью:
```bash
kafka-topics.sh --alter --topic orders --partitions 20
```

2. **Ключи**:
    - Используйте ключи для упорядоченности (например, `userID`).
    - Без ключей — round-robin для равномерного распределения.
3. **Репликация**:
    - `replication.factor=2` или 3 для отказоустойчивости, но не больше, чтобы не снижать производительность.
4. **Мониторинг**:
    - Отслеживайте лаг consumer'ов (Prometheus) для проверки, успевают ли они читать партиции.

---
### Итог

Партиции в Kafka нужны для:

- **Масштабируемости**: Распределение данных по брокерам.
- **Параллелизма**: Одновременная запись и чтение.
- **Упорядоченности**: Гарантия порядка внутри партиции.
- **Отказоустойчивости**: Репликация данных.

В Go вы используете их через настройку producer'а (`Balancer`) и consumer group. Без партиций Kafka не смогла бы обрабатывать миллионы сообщений/с, как в высоконагруженных микросервисах.


-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
