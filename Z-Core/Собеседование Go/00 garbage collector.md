2025030720:23
___
Date: 07-03-2025 | 20:23
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Как и когда включается garbage collector?

> **Garbage Collector (GC)** в Go — это встроенный механизм управления памятью, который автоматически освобождает память, занятую объектами, которые больше не используются программой. Он избавляет разработчика от ручного управления памятью (как в C), но важно понимать, как и когда он включается, чтобы оптимизировать производительность.

---
### Что такое Garbage Collector в Go?

GC в Go — это **mark-and-sweep** сборщик мусора с поколениями (generational-like), который:

1. **Mark**: Отмечает объекты, которые всё ещё достижимы (живые).
2. **Sweep**: Освобождает память объектов, которые недостижимы (мертвые).

Он работает **конкурентно** (начиная с Go 1.5), то есть выполняется параллельно с основной программой, минимизируя паузы (stop-the-world).

---
### Как работает GC в Go?

1. **Отслеживание ссылок**:
    - GC начинает с корневых объектов (глобальные переменные, стек горутин).
    - Проходит по всем ссылкам (указателям), отмечая живые объекты.
    - Всё, что не отмечено, считается мусором.
2. **Три фазы**:
    - **Mark Setup**: Подготовка (короткая пауза stop-the-world).
    - **Marking**: Отметка живых объектов (конкурентно с программой).
    - **Sweep**: Очистка памяти (выполняется лениво, по мере выделения новой памяти).
3. **Pacing**: GC регулирует свою работу, чтобы балансировать между использованием памяти и задержками.

---
### Когда включается Garbage Collector?

GC в Go запускается автоматически на основе **триггера**, который зависит от параметра **GOGC** (по умолчанию 100). Основной триггер — это рост объема выделенной памяти.

#### 1. Триггер по GOGC

- **GOGC** — это процент, определяющий, насколько может вырасти объем живой памяти (heap) после последней сборки, прежде чем GC запустится снова.
- Формула: GC запускается, когда `HeapLiveSize > HeapSizeAtLastGC * (1 + GOGC/100)`.
    - `HeapLiveSize`: Текущий объем живой памяти.
    - `HeapSizeAtLastGC`: Объем живой памяти после последней сборки.

**Пример**:

- GOGC = 100 (по умолчанию).
- После последней сборки осталось 10MB живой памяти.
- GC запустится, когда живая память превысит 20MB (10MB * (1 + 100/100)).

#### 2. Ручной запуск

- Вы можете принудительно вызвать GC с помощью `runtime.GC()`:

```go
import "runtime"

func main() {
    runtime.GC() // Принудительный запуск
}
```

- Используется редко, только для специфичных случаев (например, тесты).

#### 3. Аварийный запуск

- Если память заканчивается (out-of-memory), GC может запуститься раньше, чтобы освободить место перед паникой.

#### 4. Фоновая работа

- После Go 1.5 GC работает конкурентно, а sweeping выполняется лениво по мере необходимости выделения памяти.

---
### Пример в Go
#### Код с выделением памяти
```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func main() {
    var memStats runtime.MemStats
    runtime.GC() // Начальная очистка для чистоты эксперимента
    runtime.ReadMemStats(&memStats)
    fmt.Printf("HeapAlloc: %d bytes\n", memStats.HeapAlloc)

    // Создаем "мусор"
    for i := 0; i < 10; i++ {
        _ = make([]byte, 10<<20) // Выделяем 10MB
    }

    runtime.ReadMemStats(&memStats)
    fmt.Printf("HeapAlloc after allocation: %d bytes\n", memStats.HeapAlloc)

    time.Sleep(1 * time.Second) // Даем GC шанс сработать
    runtime.ReadMemStats(&memStats)
    fmt.Printf("HeapAlloc after GC: %d bytes\n", memStats.HeapAlloc)
}
```

- **Логика**:
    - Выделяем 100MB памяти, но не сохраняем ссылки.
    - GC запускается, когда память превышает порог GOGC, и очищает неиспользуемые массивы.
- **Вывод** (примерный):

```text
HeapAlloc: 100000 bytes
HeapAlloc after allocation: 105000000 bytes
HeapAlloc after GC: 150000 bytes
```

---
### Как управлять GC?

1. **Настройка GOGC**:
	- Увеличьте GOGC для реже запуска (меньше CPU, больше памяти):
```bash
GOGC=200 go run main.go
```

- Уменьшите для чаще запуска (меньше памяти, больше CPU):
```bash
GOGC=50 go run main.go
```

- Отключение: `GOGC=off` (не рекомендуется, память будет расти бесконечно).

- **Профилирование**:
    - Используйте `pprof` для анализа работы GC:
```go
import "runtime/pprof"
f, _ := os.Create("mem.pprof")
pprof.WriteHeapProfile(f)
```

- Запустите: go tool pprof mem.pprof.

- **Оптимизация кода**:
    - Минимизируйте выделение памяти:
```go
// Плохо: много аллокаций
for i := 0; i < 1000; i++ {
    s := make([]int, 100)
}

// Лучше: повторное использование
s := make([]int, 100)
for i := 0; i < 1000; i++ {
    // Используем s
}
```

---
### Когда GC заметен?

- **Высоконагруженные системы**: Частый GC увеличивает задержки (latency).
- **Микросервисы**: Влияет на throughput при большом количестве запросов.
- **Пример**: В реальном времени (игры, стриминг) даже короткие паузы (1-2мс) критичны.

**Метрики**:

- Включите Prometheus для мониторинга:
```go
import "github.com/prometheus/client_golang/prometheus"

runtime.ReadMemStats(&memStats)
prometheus.NewGaugeFunc(prometheus.GaugeOpts{Name: "go_heap_alloc"}, func() float64 {
    return float64(memStats.HeapAlloc)
})
```

---
### Практические советы для Go

1. **Тестируйте с GOGC**:
    - Проверьте приложение с разными значениями (50, 100, 200) под нагрузкой.
2. **Избегайте утечек**:
    - Закрывайте ресурсы (HTTP, файлы), иначе GC не освободит память:
```go
resp, _ := http.Get("example.com")
defer resp.Body.Close()
```

3. **Мониторинг**:
    - Отслеживайте `HeapAlloc`, `GCCPUFraction` в Prometheus/Grafana.
4. **Реже аллокации**:
    - Используйте пулы (`sync.Pool`) для повторного использования объектов:
```go
var pool = sync.Pool{New: func() interface{} { return make([]byte, 1024) }}
buf := pool.Get().([]byte)
defer pool.Put(buf)
```

---
### Итог

- **Как включается**: Автоматически, когда живая память превышает порог GOGC (по умолчанию 100% роста).
- **Когда**: Зависит от выделения памяти и настройки GOGC, редко — вручную (`runtime.GC()`).
- **Управление**: GOGC, профилирование, оптимизация кода.

В микросервисах с Go GC обычно незаметен, но в высоконагруженных системах требует внимания к памяти и мониторингу.

-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
