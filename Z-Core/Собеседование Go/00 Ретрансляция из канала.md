2025030418:44
___
Date: 04-03-2025 | 18:44
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Ретрансляция сообщения из канала в пять разных мест

> Чтобы ретранслировать сообщение из одного канала в пять разных мест приложения в Go, нужно организовать **рассылку** (broadcast) данных из исходного канала в несколько целевых каналов или обработчиков. В стандартной библиотеке Go нет встроенного механизма широковещательной передачи, поэтому мы реализуем это вручную с использованием горутин и каналов

---
### Подход: Фан-оут (Fan-out)

- **Суть**: Одна горутина читает из исходного канала и отправляет сообщение в несколько выходных каналов.
- **Инструменты**: Каналы, горутины, синхронизация через WaitGroup или закрытие каналов.
##### Пример кода с комментариями
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// broadcaster — функция ретрансляции сообщений из входного канала в 5 выходных
func broadcaster(input <-chan int, outputs []chan int) {
    for msg := range input { // читаем сообщения из входного канала
        for _, out := range outputs { // проходим по всем выходным каналам
            out <- msg // отправляем сообщение в каждый выходной канал
        }
    }
    // после закрытия input закрываем все выходные каналы
    for _, out := range outputs {
        close(out)
    }
}

// receiver — функция-приемник, имитирующая "место" в приложении
func receiver(id int, ch <-chan int, wg *sync.WaitGroup) {
    defer wg.Done() // сигнализируем о завершении
    for msg := range ch { // читаем из своего канала
        fmt.Printf("Приемник %d получил: %d\n", id, msg)
    }
}

func main() {
    input := make(chan int)         // входной канал для сообщений
    outputs := make([]chan int, 5)  // срез из 5 выходных каналов
    var wg sync.WaitGroup           // для ожидания завершения приемников

    // инициализируем 5 выходных каналов и приемников
    for i := 0; i < 5; i++ {
        outputs[i] = make(chan int) // создаем канал для каждого приемника
        wg.Add(1)                   // добавляем задачу в WaitGroup
        go receiver(i, outputs[i], &wg) // запускаем приемник
    }

    // запускаем ретранслятор
    go broadcaster(input, outputs)

    // отправляем сообщения в исходный канал
    for i := 1; i <= 3; i++ {
        input <- i // отправляем числа 1, 2, 3
        time.Sleep(100 * time.Millisecond) // небольшая задержка для наглядности
    }
    close(input) // закрываем исходный канал после отправки всех сообщений

    wg.Wait() // ждем, пока все приемники обработают данные
    fmt.Println("Завершено")
}
```

**Вывод** (примерный):
```text
Приемник 0 получил: 1
Приемник 1 получил: 1
Приемник 2 получил: 1
Приемник 3 получил: 1
Приемник 4 получил: 1
Приемник 0 получил: 2
Приемник 1 получил: 2
...
Завершено
```

#### Комментарии к коду

- **Входной канал (input)**: Источник сообщений.
- **Выходные каналы (outputs)**: 5 каналов, по одному для каждого "места" (приемника).
- **Ретранслятор (broadcaster)**:
    - Читает из `input` с помощью `range`.
    - Рассылает каждое сообщение в каждый канал из `outputs`.
    - Закрывает выходные каналы после закрытия `input`.
- **Приемники (receiver)**: Имитируют 5 мест приложения, читают из своих каналов.
- **Синхронизация**: `WaitGroup` ждет завершения всех приемников после закрытия каналов.

---
### Тонкости и варианты

#### 1. Небуферизированные vs буферизированные каналы

- **Небуферизированные** (как в примере): Отправка блокирует, пока все приемники не прочитают. Это гарантирует синхронность, но может замедлить работу.
- **Буферизированные**:
```go
outputs[i] = make(chan int, 10) // буфер на 10 сообщений
```

- Позволяют отправлять быстрее, но могут привести к задержкам, если приемники медленные.
#### 2. Обработка ошибок

- Если нужно учитывать сбои приемников, добавьте канал ошибок:
```go
errCh := make(chan error, 5)
go func() {
    for err := range errCh {
        fmt.Println("Ошибка:", err)
    }
}()
```

#### 3. [[00 Патерн Publish-Subscribe|Альтернатива: Publish-Subscribe]]

- Вместо фиксированных каналов可以用 паттерн pub-sub с динамической регистрацией подписчиков:
```go
subscribers := make(map[int]chan int)
```

---
### Коротко

- **Как ретранслировать**: Используйте горутину-ретранслятор, которая читает из одного канала и отправляет в несколько выходных.
- **Кто закрывает**: Отправитель закрывает исходный канал, ретранслятор — выходные после этого.
- **Тонкости**: Выбирайте буферизацию и синхронизацию в зависимости от требований.


-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
- [[00 Патерн Publish-Subscribe]]

------
**Links** (Внешние ссылки)
-
