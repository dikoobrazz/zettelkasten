2025040113:27
___
Date: 01-04-2025 | 13:27
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Паттерн Worker Pool. Реализация.

#### Определение

> Паттерн **Worker Pool** (пула рабочих) в Go — это подход к конкурентной обработке задач, где фиксированное количество горутин (рабочих) выполняет работу из общей очереди задач, поступающих через канал. Вместо создания горутины для каждой задачи, пул переиспользует ограниченный набор рабочих.
#### Преимущества

- **Контроль ресурсов**: Ограничивает количество одновременно работающих горутин, предотвращая перегрузку системы.
- **Эффективность**: Уменьшает накладные расходы на создание и уничтожение горутин.
- **Масштабируемость**: Позволяет обрабатывать большой объем задач с фиксированным потреблением памяти и CPU.

---
### Как работает?

- **Очередь задач**: Задачи поступают в канал (обычно буферизированный), из которого рабочие их берут.
- **Рабочие горутины**: Фиксированное число горутин читает задачи из канала и выполняет их параллельно.
- **Координация**: Используется `sync.WaitGroup` для ожидания завершения всех задач и закрытие канала для остановки пула.

---
### Зачем нужен?

- **Ограничение конкуренции**: Если задач тысячи, запуск горутины для каждой приведет к исчерпанию ресурсов (CPU, память). Worker Pool решает это, ограничивая число рабочих.
- **Управление нагрузкой**: Например, при запросах к внешнему API пул может ограничить число одновременных соединений.
- **Повторное использование**: Рабочие переиспользуются, что быстрее, чем создавать новые горутины.
#### Области применения

1. **Обработка запросов**: Ограничение числа HTTP-запросов к внешним сервисам.
2. **Обработка данных**: Параллельная обработка файлов, логов или записей из базы.
3. **Вычисления**: Распределение CPU-интенсивных задач (например, рендеринг изображений).
4. **Очереди задач**: Реализация асинхронной обработки (аналогично Celery или RQ).

---
### Пример
#### Задача

- Обработать список чисел (1-10), возводя их в квадрат, с использованием пула из 3 рабочих.
##### Код с комментариями
```go
package main

import (
    "fmt"
    "sync"
)

// Task — структура задачи
type Task struct {
    ID    int // идентификатор задачи
    Value int // входное значение
}

// WorkerPool — структура пула рабочих
type WorkerPool struct {
    tasks    chan Task   // канал для задач
    results  chan int    // канал для результатов
    wg       sync.WaitGroup // для ожидания завершения
    numWorkers int       // количество рабочих
}

// NewWorkerPool — конструктор пула
func NewWorkerPool(numWorkers int, bufferSize int) *WorkerPool {
    return &WorkerPool{
        tasks:    make(chan Task, bufferSize), // буферизированный канал задач
        results:  make(chan int, bufferSize),  // буферизированный канал результатов
        numWorkers: numWorkers,
    }
}

// Start — запуск рабочих
func (wp *WorkerPool) Start() {
    for i := 1; i <= wp.numWorkers; i++ { // запускаем заданное число рабочих
        wp.wg.Add(1) // увеличиваем счетчик для каждого рабочего
        go func(workerID int) {
            defer wp.wg.Done() // уменьшаем счетчик после завершения рабочего
            for task := range wp.tasks { // читаем задачи из канала
                result := task.Value * task.Value // выполняем работу (квадрат числа)
                fmt.Printf("Рабочий %d обработал задачу %d: %d -> %d\n", workerID, task.ID, task.Value, result)
                wp.results <- result // отправляем результат в канал
            }
        }(i)
    }
}

// AddTask — добавление задачи в пул
func (wp *WorkerPool) AddTask(task Task) {
    wp.tasks <- task // отправляем задачу в канал
}

// Stop — остановка пула
func (wp *WorkerPool) Stop() {
    close(wp.tasks) // закрываем канал задач, чтобы рабочие завершились
    wp.wg.Wait()    // ждем завершения всех рабочих
    close(wp.results) // закрываем канал результатов
}

func main() {
    wp := NewWorkerPool(3, 10) // создаем пул с 3 рабочими и буфером на 10 задач

    // запускаем рабочих
    wp.Start()

    // добавляем задачи
    for i := 1; i <= 10; i++ {
        wp.AddTask(Task{ID: i, Value: i})
    }

    // собираем результаты
    go wp.Stop() // запускаем остановку в отдельной горутине, чтобы не блокировать main

    sum := 0
    for result := range wp.results { // читаем результаты из канала
        sum += result
    }
    fmt.Println("Сумма квадратов:", sum) // Сумма квадратов: 385
}
```

##### Вывод (примерный)
```text
Рабочий 1 обработал задачу 1: 1 -> 1
Рабочий 2 обработал задачу 2: 2 -> 4
Рабочий 3 обработал задачу 3: 3 -> 9
Рабочий 1 обработал задачу 4: 4 -> 16
Рабочий 2 обработал задачу 5: 5 -> 25
Рабочий 3 обработал задачу 6: 6 -> 36
Рабочий 1 обработал задачу 7: 7 -> 49
Рабочий 2 обработал задачу 8: 8 -> 64
Рабочий 3 обработал задачу 9: 9 -> 81
Рабочий 1 обработал задачу 10: 10 -> 100
Сумма квадратов: 385
```

---
### Как это работает?

- **Инициализация**:
    - Создаются каналы `tasks` и `results` с буфером, чтобы избежать блокировки при добавлении задач.
    - `numWorkers` рабочих запускаются в `Start`.
- **Обработка**:
    - Каждая горутина читает из `tasks`, выполняет работу (возведение в квадрат) и отправляет результат в `results`.
- **Завершение**:
    - Stop закрывает канал задач, рабочие завершают работу, `WaitGroup` ждет их, затем закрывается канал результатов.
- **Почему каналы?**:
    - Каналы обеспечивают безопасную передачу задач и результатов между горутинами.
    - Буферизация позволяет добавлять задачи, даже если рабочие заняты.

---
### Как реализовать паттерн Worker Pool?

1. **Определите задачу**: Создайте структуру (`Task`) для данных, которые нужно обработать.
2. **Создайте пул**: Определите структуру (`WorkerPool`) с каналами и настройками.
3. **Запустите рабочих**: Используйте цикл для запуска горутин, читающих из канала задач.
4. **Добавляйте задачи**: Отправляйте задачи в канал через метод (`AddTask`).
5. **Собирайте результаты**: Читайте из канала результатов в главной горутине или отдельной.
6. **Остановите пул**: Закройте канал задач и дождитесь завершения с `WaitGroup`.
##### Расширенный пример с ошибками
```go
type TaskResult struct {
    ID     int
    Result int
    Err    error
}

func (wp *WorkerPool) StartWithErrors() {
    for i := 1; i <= wp.numWorkers; i++ {
        wp.wg.Add(1)
        go func(workerID int) {
            defer wp.wg.Done()
            for task := range wp.tasks {
                if task.Value == 5 { // имитация ошибки
                    wp.results <- TaskResult{ID: task.ID, Err: fmt.Errorf("ошибка на задаче %d", task.ID)}
                    continue
                }
                result := task.Value * task.Value
                wp.results <- TaskResult{ID: task.ID, Result: result}
            }
        }(i)
    }
}
```

---
### Лучшие практики

1. **Буферизация**: Используйте буфер для канала задач, чтобы избежать блокировки при добавлении (`make(chan Task, n)`).
2. **Ограничение рабочих**: Число рабочих должно соответствовать ресурсам (например, `runtime.NumCPU()`).
3. **Обработка ошибок**: Передавайте ошибки через канал результатов, как в расширенном примере.
4. **Закрытие каналов**: Всегда закрывайте каналы корректно для завершения работы.
5. **Мониторинг**: Добавляйте логирование или метрики для отслеживания производительности пула.

---
### Итог

- **Worker Pool**: Пул фиксированного числа горутин, обрабатывающих задачи из канала.
- **Зачем нужен**: Контроль ресурсов, управление нагрузкой, повторное использование горутин.
- **Применение**: Обработка запросов, данных, вычислений.
- Реализация проста: каналы для задач и результатов, рабочие в горутинах, синхронизация через `WaitGroup`.


-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
