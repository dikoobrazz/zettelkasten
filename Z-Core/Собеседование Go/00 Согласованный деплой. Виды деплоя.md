2025030717:58
___
Date: 07-03-2025 | 17:58
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Согласованный деплой. Виды деплоя

> **Согласованный деплой** и виды деплоя — это важные аспекты в разработке и эксплуатации микросервисов, которые влияют на надежность, доступность и скорость выпуска обновлений.

---
### Что такое согласованный деплой?

**Согласованный деплой** — это процесс развертывания приложения, при котором обеспечивается совместимость и согласованность между различными компонентами системы (например, микросервисами, базами данных, внешними зависимостями) во время обновления. Цель — избежать ситуаций, когда старая версия сервиса работает с новой версией БД или наоборот, что может привести к ошибкам.

**Пример проблемы**:

- OrderService v1 ожидает поле price в БД, а новая схема БД в v2 переименовала его в cost. Без согласованности v1 сломается.

**Решение**:

- Постепенное развертывание с учетом обратной совместимости.
- Использование версионирования API или схем.

---
### Виды деплоя

Существует несколько стратегий деплоя, каждая из которых решает разные задачи: минимизация downtime, тестирование в проде, управление рисками.

#### 1. Recreate (Пересоздание)

- **Описание**: Старая версия приложения полностью останавливается, затем запускается новая.
- **Процесс**:
    1. Остановить все инстансы `v1`.
    2. Запустить инстансы `v2`.
- **Пример в Kubernetes**:
```yml
apiVersion: apps/v1
kind: Deployment
spec:
  strategy:
    type: Recreate
```

- **Плюсы**:
    - Простота реализации.
    - Подходит для приложений без требований к доступности.
- **Минусы**:
    - Downtime (время простоя).
    - Нет отката без ручного вмешательства.
- **Когда использовать**: Тестовые среды, некритичные системы.
#### 2. Rolling Update (Плавное обновление)

- **Описание**: Новая версия постепенно заменяет старую, инстанс за инстансом, без полной остановки.
- **Процесс**:
    1. Запускается один инстанс `v2`.
    2. Один инстанс `v1` останавливается.
    3. Повторяется до полной замены.
- **Пример в Kubernetes**:
```yml
apiVersion: apps/v1
kind: Deployment
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1        # Сколько новых подов сверх нормы
      maxUnavailable: 0  # Сколько подов могут быть недоступны
```

- **Плюсы**:
    - Нет downtime (zero-downtime при правильной настройке).
    - Постепенное обновление снижает риск.
- **Минусы**:
    - Требует обратной совместимости (v1 и v2 работают одновременно).
    - Медленнее, чем Recreate.
- **Когда использовать**: Большинство продакшен-систем.
#### 3. Blue-Green Deployment (Сине-зеленый деплой)

- **Описание**: Две идентичные среды (синяя — текущая, зеленая — новая). После успешного тестирования зеленой среды трафик переключается на нее.
- **Процесс**:
    1. Синяя (`v1`) обслуживает трафик.
    2. Зеленая (`v2`) разворачивается рядом.
    3. Тестируется `v2`.
    4. Балансировщик переключает трафик на `v2`.
    5. Синяя среда отключается.
- **Пример в Kubernetes**:
    
    - Два Deployment'а (`blue` и `green`) + Service с переключением `selector`.

```yml
apiVersion: v1
kind: Service
spec:
  selector:
    app: my-app
    version: green # Переключение на v2
```

- **Плюсы**:
    - Zero-downtime.
    - Быстрый откат (переключение на синюю).
- **Минусы**:
    - Требует двойных ресурсов.
    - Сложнее синхронизировать БД.
- **Когда использовать**: Высоконагруженные системы с жесткими требованиями к доступности.

#### 4. Canary Deployment (Канареечный деплой)

- **Описание**: Новая версия (`v2`) разворачивается для небольшой части трафика, чтобы протестировать ее в проде, затем постепенно расширяется.
- **Процесс**:
    1. 5% трафика идет на `v2`, 95% на `v1`.
    2. Мониторинг ошибок и производительности.
    3. Увеличение доли `v2` до 100%.
- **Пример в Kubernetes с Istio**:

```yml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
spec:
  hosts:
  - my-service
  http:
  - route:
    - destination:
        subset: v1
      weight: 95
    - destination:
        subset: v2
      weight: 5
```

- **Плюсы**:
    - Минимизация риска (тест на реальном трафике).
    - Zero-downtime.
- **Минусы**:
    - Требует service mesh (Istio, Linkerd) или умного балансировщика.
    - Сложнее управлять совместимостью.
- **Когда использовать**: Сложные системы, где нужно тестировать в проде.

#### 5. Shadow Deployment (Теневой деплой)

- **Описание**: Новая версия (`v2`) получает копию трафика, но не влияет на пользователей (ответы не возвращаются).
- **Процесс**:
    1. Трафик дублируется на `v2`.
    2. Сравниваются ответы `v1` и `v2`.
    3. После валидации `v2` становится основной.
- **Пример**: Istio Traffic Mir

roring:
```yml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
spec:
  http:
  - route:
    - destination:
        subset: v1
    mirror:
      subset: v2
```

- **Плюсы**:
    - Безопасное тестирование.
    - Нет влияния на пользователей.
- **Минусы**:
    - Удваивает нагрузку.
    - Требует сложной инфраструктуры.
- **Когда использовать**: Критические системы перед полным переходом.

---
### Что такое согласованный деплой в этом контексте?

Согласованность достигается через:

- **Обратная совместимость**: `v2` поддерживает старые API и схемы БД.
- **Постепенность**: Использование Rolling Update, Canary или Blue-Green для плавного перехода.
- **Миграции БД**: Сначала добавляются новые поля, затем убираются старые.

**Пример в Go** (обратная совместимость):
```go
type Order struct {
    ID    string `json:"id"`
    Price int    `json:"price"` // Старое поле
    Cost  int    `json:"cost,omitempty"` // Новое поле для v2
}
```

- `v1` использует `Price`, `v2` переходит на `Cost`, оба работают одновременно.

---
### Основные виды деплоя (Best Practices)

1. **Rolling Update**:
    - **Почему**: Простота, zero-downtime, стандарт в Kubernetes.
    - **Когда**: Большинство случаев, если нет сложных зависимостей.
    - **Совет**: Настройте `maxUnavailable` и `maxSurge` для контроля.
2. **Blue-Green**:
    - **Почему**: Высокая надежность, быстрый откат.
    - **Когда**: Критические системы с высокими требованиями к доступности.
    - **Совет**: Автоматизируйте переключение через CI/CD (GitHub Actions, Jenkins).
3. **Canary**:
    - **Почему**: Тестирование в проде, снижение риска.
    - **Когда**: Сложные микросервисы, где нужна обратная связь от пользователей.
    - **Совет**: Используйте Istio или прогрессивный деплой в ArgoCD.

---
### Практические советы для Go

1. **Health Checks**:
    - Добавьте /health для Rolling Update:

```go
http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
    w.Write([]byte("OK"))
})
```

- Kubernetes: `livenessProbe` и `readinessProbe`.

2. **Graceful Shutdown**:
    - Обрабатывайте завершение корректно:

```go
srv := &http.Server{Addr: ":8080"}
go func() {
    <-ctx.Done()
    srv.Shutdown(context.Background())
}()
```

3. **Версионирование**:
    - Используйте `/v1/` и `/v2/` в API для совместимости.

---
### Итог

- **Согласованный деплой**: Обеспечение совместимости между версиями через постепенность и обратную совместимость.
- **Виды деплоя**: Recreate, Rolling Update, Blue-Green, Canary, Shadow.
- **Best Practices**: Rolling Update (простота), Blue-Green (надежность), Canary (тестирование).

В микросервисах с Go чаще всего используют Rolling Update для базовых случаев и Canary/Blue-Green для продвинутых сценариев с Kubernetes.

-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
