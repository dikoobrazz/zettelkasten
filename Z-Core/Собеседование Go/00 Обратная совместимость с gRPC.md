2025030422:20
___
Date: 04-03-2025 | 22:20
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Обратная совместимость с gRPC

> Обратная совместимость в **gRPC** обеспечивается через правильное управление схемами **Protocol Buffers (Protobuf)**, которые лежат в основе данных gRPC. Так как gRPC использует HTTP/2 и Protobuf для сериализации, совместимость зависит от того, как вы изменяете .proto файлы, чтобы старые клиенты и серверы могли продолжать работать с новыми версиями. 

---
### Как работает обратная совместимость?

#### Основной принцип

- **Protobuf** использует номера полей (field numbers) вместо имен для идентификации данных в бинарном формате.
- Обратная совместимость достигается, если:
    - Старые клиенты/серверы могут игнорировать новые поля.
    - Новые клиенты/серверы корректно обрабатывают отсутствие старых полей.
#### Ключевые правила

1. **Не удаляйте поля полностью**:
    - Вместо удаления пометьте поле как deprecated или зарезервируйте его номер (reserved).
2. **Не меняйте номера полей**:
    - Номер привязан к данным в бинарном формате, изменение ломает совместимость.
3. **Не меняйте типы существующих полей**:
    - Например, с int32 на string — это нарушает десериализацию.
4. **Добавляйте новые поля с новыми номерами**:
    - Старые версии просто игнорируют их.

---
### Как это работает на практике?
#### 1. Старый клиент + новый сервер

- Новый сервер добавляет поле, старый клиент его не видит и игнорирует.
- Protobuf заполняет отсутствующие поля значениями по умолчанию (например, 0 для чисел, пустая строка для строк).
#### 2. Новый клиент + старый сервер

- Новый клиент ожидает новое поле, но старый сервер его не отправляет.
- Protobuf возвращает значение по умолчанию для отсутствующего поля.

---
### Пример в .proto
##### Исходная версия (v1)
```go
syntax = "proto3";
package example;

service Greeter {
    rpc SayHello (HelloRequest) returns (HelloReply);
}

message HelloRequest {
    string name = 1;
}

message HelloReply {
    string message = 1;
}
```

Клиент отправляет `name`, сервер отвечает `message`.
##### Новая версия (v2) с добавлением поля
```go
syntax = "proto3";
package example;

service Greeter {
    rpc SayHello (HelloRequest) returns (HelloReply);
}

message HelloRequest {
    string name = 1;
    int32 age = 2; // новое поле
}

message HelloReply {
    string message = 1;
    string greeting = 2; // новое поле
}
```

- **Совместимость**:
    - Старый клиент отправляет только `name`, сервер v2 видит `age = 0` (по умолчанию).
    - Старый сервер отвечает только `message`, клиент v2 видит `greeting = ""` (по умолчанию).

##### Пример с удалением (нельзя так делать)
```go
message HelloRequest {
    // string name = 1; // удалено — ломает совместимость!
    int32 age = 2;
}
```

- **Проблема**: Старый клиент отправляет `name` с номером 1, новый сервер интерпретирует это как `age`, что нарушает логику.

##### Корректное "удаление"
```go
message HelloRequest {
    reserved 1; // зарезервировали номер 1, чтобы не использовать
    // или: deprecated string name = 1; (оставить как устаревшее)
    int32 age = 2;
}
```

**Итог**: Старый клиент отправляет name, новый сервер игнорирует поле 1.

---
### Пример в Go
##### Сервер v1
```go
type server struct {
    pb.UnimplementedGreeterServer
}

func (s *server) SayHello(ctx context.Context, req *pb.HelloRequest) (*pb.HelloReply, error) {
    return &pb.HelloReply{Message: "Hello, " + req.Name}, nil
}
```
##### Сервер v2 (с новым полем)
```go
func (s *server) SayHello(ctx context.Context, req *pb.HelloRequest) (*pb.HelloReply, error) {
    msg := fmt.Sprintf("Hello, %s (age: %d)", req.Name, req.Age)
    return &pb.HelloReply{Message: msg, Greeting: "Hi!"}, nil
}
```

- **Комментарий**:
    - Старый клиент отправляет `{name: "Alice"}`, `req.Age = 0` по умолчанию.
    - Новый сервер отвечает `{message: "Hello, Alice (age: 0)", greeting: "Hi!"}`, старый клиент игнорирует `greeting`.

##### Клиент v1
```go
conn, _ := grpc.Dial("localhost:50051", grpc.WithInsecure())
client := pb.NewGreeterClient(conn)
resp, _ := client.SayHello(context.Background(), &pb.HelloRequest{Name: "Alice"})
fmt.Println(resp.Message) // Hello, Alice (age: 0)
```

##### Клиент v2
```go
resp, _ := client.SayHello(context.Background(), &pb.HelloRequest{Name: "Bob", Age: 25})
fmt.Println(resp.Message, resp.Greeting) // Hello, Bob (age: 25) Hi!
```

- **Комментарий**: Клиент v2 видит все поля, v1 — только `message`.

---
### Тонкости обратной совместимости

1. **Значения по умолчанию**:
    - Если новое поле не отправлено, клиент/сервер использует дефолтное значение (0, "", false).
    - Учитывайте это в логике (например, `age = 0` может быть валидным значением).
2. **Зарезервированные номера**:
    - Используйте `reserved` для удаленных полей, чтобы избежать конфликтов в будущем.
3. **Повторяющиеся поля**:
    - `repeated` поля (списки) совместимы, если добавлять элементы, но не менять их тип.
4. **Метаданные**:
    - gRPC передает метаданные через HTTP/2 заголовки, их изменения не ломают совместимость Protobuf.
5. **Версионирование**:
    - Рекомендуется хранить разные версии `.proto` (v1, v2) и тестировать совместимость.

---
### Коротко

- **Как работает**: Обратная совместимость в gRPC основана на Protobuf — новые поля добавляются с новыми номерами, старые не удаляются, а резервируются.
- **Принцип**: Старые версии игнорируют новые поля, новые используют значения по умолчанию для старых.
- **Тонкости**: Не меняйте номера/типы, учитывайте дефолтные значения.

-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
