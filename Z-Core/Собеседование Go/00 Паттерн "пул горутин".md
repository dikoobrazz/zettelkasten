2025040221:35
___
Date: 02-04-2025 | 21:35
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## ### **Пул горутин**

Когда ты работаешь с большим количеством горутин, часто бывает полезно ограничить количество одновременно выполняющихся горутин, чтобы избежать перегрузки системы. Это можно сделать с помощью **пула горутин**.

##### Пример: Пул горутин с ограничением на количество рабочих горутин
```go
package main

import (
	"fmt"
	"sync"
)

func worker(id int, ch <-chan int, wg *sync.WaitGroup) {
	defer wg.Done()
	for job := range ch {
		fmt.Printf("Рабочий %d обрабатывает задачу %d\n", id, job)
	}
}

func main() {
	var wg sync.WaitGroup
	ch := make(chan int, 10) // Канал с задачами
	numWorkers := 3          // Число рабочих горутин

	// Создаём пул горутин
	for i := 1; i <= numWorkers; i++ {
		wg.Add(1)
		go worker(i, ch, &wg)
	}

	// Отправляем задачи в канал
	for i := 1; i <= 10; i++ {
		ch <- i
	}
	close(ch) // Закрываем канал, чтобы рабочие завершили работу

	wg.Wait() // Ждём завершения всех горутин
}
```

### Объяснение:

- Мы создаём пул из нескольких горутин (в данном случае 3).
- Каждая горутина читает из канала `ch` и обрабатывает задачу.
- Канал используется для задания горутинам задачи. Как только задачи отправлены, мы закрываем канал и ждём, пока все горутины завершат работу, используя `WaitGroup`.
##### Вывод:
```text
Рабочий 1 обрабатывает задачу 1
Рабочий 2 обрабатывает задачу 2
Рабочий 3 обрабатывает задачу 3
Рабочий 1 обрабатывает задачу 4
Рабочий 2 обрабатывает задачу 5
...
```

### Почему это полезно:

- Мы ограничиваем число одновременно работающих горутин с помощью пула.
- Это помогает нам контролировать нагрузку и предотвращать перегрузку системы, например, в случае обработки большого числа запросов или задач.

-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
