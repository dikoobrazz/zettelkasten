2025030317:17
___
Date: 03-03-2025 | 17:17
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Переключение контекста между горутинами

> Переключение контекста между горутинами в Go — это процесс, который управляется **runtime-планировщиком Go** (scheduler), а не операционной системой. Это ключевая особенность, делающая горутины легковесными и эффективными.

---
### Что такое контекст в этом случае?

- **Контекст горутины** — это состояние выполнения: текущий указатель инструкций (PC — program counter), стек, регистры (включая указатель стека SP), и данные, необходимые для продолжения работы.
- При переключении контекста это состояние сохраняется для одной горутины и восстанавливается для другой.

---
### Как переключается контекст?
#### 1. Модель M:N

- Go использует модель **M:N**, где *M* горутин мультиплексируются на *N* потоков ОС (OS threads).
- **Компоненты**:  
    - **G (Goroutine)**: Легковесный поток выполнения (горутина).
    - **M (Machine)**: Поток ОС, управляемый ядром.
    - **P (Processor)**: Логический процессор Go, связывающий G и M (P равно `GOMAXPROCS`).
- Планировщик Go распределяет горутины (G) по процессорам (P), которые выполняются в потоках ОС (M).
#### 2. Планировщик Go (Scheduler)

- **Где живет**: Встроен в runtime Go (внутри процесса программы).
- **Задача**: Переключать горутины внутри потоков ОС, минимизируя накладные расходы.
- **Как работает**:  
    - Следит за состоянием горутин (running, runnable, waiting).
    - Решает, когда одну горутину приостановить, а другую запустить.
#### 3. Моменты переключения
Переключение контекста происходит в определенных точках:

1. **Блокировка**:  
    - Горутина вызывает операцию, которая блокирует (например, чтение из канала, `time.Sleep`, системный вызов вроде I/O).
    - Пример: `<-ch` (если канал пуст) или `os.ReadFile`.
2. **Прерывание по времени**:  
    - Планировщик периодически вмешивается (примерно каждые 10 мс), если горутина работает долго (cooperative scheduling).
    - Это зависит от сигналов таймера и точек уступки (yield points).
3. **Явная уступка**:  
    - Вызов `runtime.Gosched()` вручную уступает управление другой горутине.
4. **Системные вызовы**:  
    - Если горутина вызывает блокирующий syscall (например, `read` от файла), планировщик паркует её и запускает другую.
#### 4. Процесс переключения

- **Сохранение контекста**:  
    - Текущая горутина (G1) приостанавливается.
    - Её PC, SP и данные стека сохраняются в структуре g (внутренний объект Go runtime).
- **Восстановление контекста**:  
    - Выбирается следующая горутина (G2) из очереди runnable (готовых к выполнению).
    - Её PC, SP и стек загружаются в регистры.
- **Переключение**:  
    - Процессор начинает выполнять код G2 с точки, где она остановилась.
- Это происходит **внутри одного потока ОС**, без переключения контекста ядра (в отличие от потоков).
#### 5. Почему быстро?

- Переключение горутин (~100-200 нс) быстрее переключения потоков ОС (~1-10 мкс), так как:
    - Нет системных вызовов к ядру.
    - Управление в user-space (runtime Go).
    - Меньше данных сохраняется (только PC, SP, минимум регистров).

---
##### Пример кода с комментариями
```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func worker(id int) {
    // Цикл имитирует долгую работу
    for i := 0; i < 5; i++ {
        fmt.Printf("Горутина %d: шаг %d\n", id, i)
        // Уступка контекста вручную для демонстрации
        runtime.Gosched()
    }
}

func main() {
    // Ограничиваем 1 поток ОС для чистоты эксперимента
    runtime.GOMAXPROCS(1)

    // Запускаем 3 горутины
    go worker(1) // Горутина 1
    go worker(2) // Горутина 2
    go worker(3) // Горутина 3

    // Даем время для работы горутин
    time.Sleep(1 * time.Second)
    fmt.Println("Завершение main")
}
```

- **Комментарии**:  
    - runtime.GOMAXPROCS(1): Все горутины работают в одном потоке ОС, переключаясь планировщиком.
    - go worker(): Создаются 3 горутины, которые добавляются в очередь runnable.
    - runtime.Gosched(): Явно уступает управление другой горутине, вызывая переключение контекста.
    - Планировщик чередует выполнение worker(1), worker(2), worker(3) в одном потоке.
- **Вывод** (примерный):

```text
Горутина 1: шаг 0
Горутина 2: шаг 0
Горутина 3: шаг 0
Горутина 1: шаг 1
...
Завершение main
```

#### С переключением по таймеру

- Без `Gosched()` переключение происходит по таймеру (каждые ~10 мс) или при блокировке (например, `time.Sleep`).
  
---
### Как планировщик выбирает горутину?

- **Очереди**:  
    - **Runqueue**: Локальная очередь на каждом P (до 256 горутин) + глобальная очередь.
    - Горутины в состоянии runnable ждут в очереди.
- **Алгоритм**:  
    - FIFO (first-in, first-out) с приоритетами для системных вызовов.
    - Work-stealing: Если P простаивает, он "крадет" горутины у других P.
- **Точки переключения**: Проверяются компилятором в коде (например, вызовы функций, циклы).

---
##### Пример с блокировкой
```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan int) // Небуферизированный канал

    go func() {
        fmt.Println("Горутина 1: отправляю")
        ch <- 42 // Блокируется, пока нет получателя
        fmt.Println("Горутина 1: отправлено")
    }()

    go func() {
        time.Sleep(500 * time.Millisecond) // Задержка
        fmt.Println("Горутина 2: получаю")
        value := <-ch // Блокируется, пока нет отправителя
        fmt.Println("Горутина 2: получено", value)
    }()

    time.Sleep(1 * time.Second) // Ждем завершения
}
```

- **Комментарии**:  
    - Горутина 1 блокируется на `ch <- 42`, планировщик переключает контекст на Горутину 2.
    - Горутина 2 ждет 500 мс, затем читает из канала, разблокируя Горутину 1.
    - Планировщик переключает контекст между ними при блокировках.

---
### Подводные камни

1. **Задержки**: Если горутина не блокируется и не уступает, она может "захватить" поток.  
    - Решение: Используйте `runtime.Gosched()` или каналы.
2. **Ограничение потоков**: Если `GOMAXPROCS=1`, переключение только внутри одного потока.
3. **Системные вызовы**: Блокирующий syscall паркует горутину, создавая временный поток.
  
---
### Итог

Переключение контекста между горутинами:

- Управляется **планировщиком Go** внутри runtime.
- Происходит при блокировках (каналы, I/O), таймере (~10 мс) или `Gosched()`.
- Быстро благодаря легкости (без системных вызовов ядра).
- Использует модель M:N, распределяя горутины по потокам ОС.

Это делает Go идеальным для конкурентности.


-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
