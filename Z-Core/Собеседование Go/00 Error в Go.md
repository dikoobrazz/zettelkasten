2025022422:53
___
Date: 24-02-2025 | 22:53
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Что такое error в Go и какие бывают?

В **Go error** — это встроенный интерфейс, который используется для обработки и передачи ошибок в программе. Это один из ключевых элементов философии языка, где ошибки рассматриваются как обычные значения, а не исключения (как в Java или Python). Такой подход делает обработку ошибок явной и предсказуемой.

### Что такое error?

> **error** — это интерфейс, определенный в стандартной библиотеке:

```go
type error interface {
    Error() string
}
```

Любой тип, который реализует метод **Error() string**, автоматически является **error**. Это значит, что вы можете создавать свои собственные ошибки, просто реализуя этот интерфейс.

Самый простой способ создать ошибку — использовать функцию **errors.New()** или **fmt.Errorf():**
```go
import "errors"

err := errors.New("что-то пошло не так") // Простая ошибка
```

### Как работает обработка ошибок?

В Go функции часто возвращают результат и ошибку как два значения. Вы проверяете ошибку и решаете, что с ней делать:
```go
func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("деление на ноль")
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println("Ошибка:", err)
        return
    }
    fmt.Println("Результат:", result)
}
```

Если **err != nil**, значит, произошла ошибка, и нужно её обработать. Если **err == nil**, операция прошла успешно.

### Какие бывают ошибки в Go?

#### 1. Встроенные ошибки

Go предоставляет несколько стандартных ошибок в пакете **errors** и других библиотеках:

- **errors.New("текст")**: Создает простую ошибку с заданным текстом.
- **fmt.Errorf("текст %v", arg)**: Форматирует ошибку с переменными.
- Примеры из стандартных пакетов:  
    - **io.EOF:** Конец файла (не ошибка в строгом смысле, а индикатор).
    - **os.ErrNotExist:** Файл или директория не существует.
    - **context.DeadlineExceeded**: Превышен дедлайн контекста.


#### 2. Пользовательские ошибки

Вы можете создать свой тип ошибки, реализовав интерфейс **error**. Это полезно для передачи дополнительной информации:

```go
type MyError struct {
    Code    int
    Message string
}

func (e *MyError) Error() string {
    return fmt.Sprintf("ошибка %d: %s", e.Code, e.Message)
}

func riskyOperation() error {
    return &MyError{Code: 404, Message: "ресурс не найден"}
}

func main() {
    if err := riskyOperation(); err != nil {
        fmt.Println(err) // Вывод: ошибка 404: ресурс не найден
    }
}
```

#### 3. Обертывание ошибок (Wrapping)

Начиная с Go 1.13, появилась возможность "оборачивать" ошибки с помощью **fmt.Errorf** и спецификатора **%w**. Это позволяет строить цепочки ошибок и проверять их позже с помощью **errors.Is() и errors.As():**

```go
func innerFunc() error {
    return errors.New("базовая ошибка")
}

func outerFunc() error {
    err := innerFunc()
    if err != nil {
        return fmt.Errorf("внешняя ошибка: %w", err)
    }
    return nil
}

func main() {
    err := outerFunc()
    if err != nil {
        fmt.Println(err) // Вывод: внешняя ошибка: базовая ошибка
        if errors.Is(err, errors.New("базовая ошибка")) {
            fmt.Println("Это базовая ошибка")
        }
    }
}
```

- **errors.Is(err, target)**: Проверяет, является ли ошибка или одна из её "обёрток" равной целевой ошибке.
- **errors.As(err, target)**: Извлекает ошибку определенного типа из цепочки.

#### 4. Типичные категории ошибок

Ошибки в Go можно условно разделить по их природе:
  
- **Системные**: Ошибки ввода-вывода, сетевые сбои (**io.ErrUnexpectedEOF, net.ErrClosed**).
- **Логические**: Ошибки валидации, деление на ноль, неверные аргументы.
- **Контекстные**: Связанные с **context** (**context.Canceled, context.DeadlineExceeded**).
- **Пользовательские**: Специфичные для вашего приложения (например, **ErrUserNotFound**).

### Нюансы и лучшие практики

1. **Явная обработка**: Всегда проверяйте **err != nil** после вызова функции, которая может вернуть ошибку.
2. **Не игнорировать ошибки**: Использование **_** для игнорирования ошибок допустимо только если это осознанное решение.
3. **Обогащение ошибок**: Используйте обертывание для добавления контекста (где и почему ошибка возникла).
4. **Sentinel-ошибки**: Создавайте глобальные переменные для уникальных ошибок (например, 
	**var ErrNotFound = errors.New("not found"))**, чтобы их можно было проверять через **errors.Is()**.

### Пример с обертыванием и проверкой
```go
package main

import (
    "errors"
    "fmt"
)

var ErrNotFound = errors.New("не найдено")

func fetchData(id int) error {
    if id == 0 {
        return ErrNotFound
    }
    return nil
}

func process(id int) error {
    if err := fetchData(id); err != nil {
        return fmt.Errorf("ошибка обработки id %d: %w", id, err)
    }
    return nil
}

func main() {
    err := process(0)
    if err != nil {
        fmt.Println(err) // Вывод: ошибка обработки id 0: не найдено
        if errors.Is(err, ErrNotFound) {
            fmt.Println("Ресурс не найден")
        }
    }
}
```

### Зачем это важно для Go разработчика?

- **Надежность**: Явная обработка ошибок предотвращает скрытые сбои.
- **Читаемость**: Код становится линейным и предсказуемым.
- **Гибкость**: Пользовательские ошибки и обертывание позволяют строить сложную логику обработки.

В роли Middle Go Developer я бы сказал, что умение грамотно работать с **error** — это признак зрелости. Если есть конкретный кейс, я могу показать, как применить эти концепции! Что скажете?


-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
