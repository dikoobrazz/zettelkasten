2025030417:42
___
Date: 04-03-2025 | 17:42
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Почему может зависнуть горутина

> Горутина в Go может зависнуть (остаться в состоянии ожидания или блокировки без возможности продолжить выполнение) по нескольким причинам, связанным с конкурентностью и синхронизацией.

___
### Почему может зависнуть горутина?

1. **Блокировка на канале без отправителя/получателя**
    
    - Если горутина ждет данных из канала (`<-ch`) или отправляет в него (`ch <- val`), а другая сторона не готова (нет пары), она блокируется навсегда.

```go
func main() {
    ch := make(chan int) // небуферизированный канал
    go func() {
        <-ch // горутина ждет данные, но никто не отправляет
        fmt.Println("никогда не выполнится")
    }()
    time.Sleep(1 * time.Second) // main завершается, горутина зависает
}
```

-  **Причина**: Нет отправителя в `ch`, горутина бесконечно ждет.

2. **Дедлок (deadlock)**
    - Все горутины блокируют друг друга, ожидая действий, которые никто не выполнит.

```go
func main() {
    ch1 := make(chan int)
    ch2 := make(chan int)
    go func() {
        ch1 <- 1   // отправка в ch1, но никто не читает
        <-ch2      // ожидание из ch2
    }()
    go func() {
        ch2 <- 2   // отправка в ch2, но никто не читает
        <-ch1      // ожидание из ch1
    }()
    time.Sleep(1 * time.Second) // дедлок: все ждут друг друга
}
```

- **Причина**: Каждая горутина ждет другую, создавая цикл ожиданий.

3. **Бесконечный цикл без уступки**
    - Горутина выполняет CPU-интенсивную задачу без точек переключения (например, без `runtime.Gosched()` или блокировок).

```go
func main() {
    runtime.GOMAXPROCS(1) // один поток ОС
    go func() {
        for { // бесконечный цикл без I/O или уступки
            i := 0
            i++
        }
    }()
    fmt.Println("main") // может не выполниться, горутина не уступает
    time.Sleep(1 * time.Second)
}
```

- **Причина**: Планировщик не прерывает горутину без точек уступки, если `GOMAXPROCS=1`.

4. **Ожидание мьютекса, который не разблокируется**
    - Горутина блокируется на `Lock()`, если другая горутина забыла вызвать `Unlock()`.

```go
func main() {
    var mu sync.Mutex
    go func() {
        mu.Lock() // захватываем мьютекс
        // забыли Unlock()
    }()
    time.Sleep(100 * time.Millisecond)
    mu.Lock() // main зависает, ожидая разблокировки
    fmt.Println("никогда не выполнится")
}
```

-  **Причина**: Мьютекс остался заблокированным.

5. **Ожидание условия без сигнала**
    - Использование `sync.Cond` без вызова `Signal()` или `Broadcast()`.

```go
func main() {
    cond := sync.NewCond(&sync.Mutex{})
    go func() {
        cond.L.Lock()
        cond.Wait() // ожидание сигнала, который не приходит
        fmt.Println("никогда не выполнится")
        cond.L.Unlock()
    }()
    time.Sleep(1 * time.Second) // main завершается, горутина зависает
}
```

 - **Причина**: Нет вызова cond.Signal() для разблокировки.

---
### Коротко: Основные причины зависания

- **Блокировка канала**: Нет пары для отправки/получения.
- **Дедлок**: Взаимное ожидание ресурсов.
- **Бесконечный цикл**: Нет точек переключения при `GOMAXPROCS=1`.
- **Мьютекс**: Не разблокирован.
- **Cond**: Нет сигнала.

---
### Как избежать?

- Используйте буферизированные каналы или тайм-ауты (`select` с `time.After`).
- Проверяйте логику синхронизации на дедлоки.
- Добавляйте `runtime.Gosched()` или точки блокировки в циклах.
- Всегда разблокируйте мьютексы (`defer mu.Unlock()`).
- Убедитесь, что `Cond` получает сигнал.

-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
