2025040113:23
___
Date: 01-04-2025 | 13:23
Tags: #
mapofcontents: [[zero-links|OO Links]]
___
## Паттерны fan-in fan-out
#### Определение

**Fan-In** и **Fan-Out** — это паттерны конкурентной обработки данных в Go, использующие горутины и каналы для распределения и агрегации задач.

- **Fan-Out**: Одна горутина (производитель) отправляет задачи в несколько горутин (рабочих) через каналы, распределяя нагрузку.
- **Fan-In**: Несколько горутин (рабочих) отправляют результаты в одну горутину (сборщик) через каналы, объединяя данные.
#### Преимущества

- **Fan-Out**: Параллельная обработка задач, ускорение выполнения за счет распределения.
- **Fan-In**: Эффективное объединение результатов из нескольких источников в один поток.
- Вместе: Позволяют строить масштабируемые конвейеры обработки данных.

---
### Как работают?

- **Fan-Out**:
    - Один источник (producer) создает задачи и отправляет их в несколько каналов или рабочих горутин.
    - Каждая горутина обрабатывает свою часть данных независимо.
- **Fan-In**:
    - Несколько рабочих отправляют результаты в общий канал.
    - Одна горутина (consumer) читает из этого канала и собирает данные.
- **Комбинация**: Fan-Out распределяет работу, Fan-In собирает итоги, образуя полный цикл обработки.

---
### Пример
#### Задача

- Сгенерировать числа (1-10).
- Распределить их между рабочими (Fan-Out) для возведения в квадрат.
- Собрать результаты в один поток (Fan-In) и вывести сумму.
##### Код с комментариями
```go
package main

import (
    "fmt"
    "sync"
)

// generator — генерирует числа и отправляет их в канал (источник для Fan-Out)
func generator(max int) <-chan int {
    out := make(chan int, max) // буферизированный канал для чисел
    go func() {
        defer close(out) // закрываем канал после генерации
        for i := 1; i <= max; i++ {
            out <- i // отправляем числа в канал
        }
    }()
    return out
}

// squareWorker — рабочая горутина, возводит числа в квадрат (Fan-Out)
func squareWorker(id int, in <-chan int) <-chan int {
    out := make(chan int) // канал для результатов рабочего
    go func() {
        defer close(out) // закрываем канал после обработки
        for num := range in { // читаем числа из входного канала
            result := num * num // возводим в квадрат
            fmt.Printf("Рабочий %d: %d -> %d\n", id, num, result)
            out <- result // отправляем результат в выходной канал
        }
    }()
    return out
}

// fanIn — собирает результаты из нескольких каналов в один (Fan-In)
func fanIn(channels ...<-chan int) <-chan int {
    var wg sync.WaitGroup
    out := make(chan int) // единый канал для всех результатов

    // функция для переноса данных из одного канала в out
    output := func(ch <-chan int) {
        defer wg.Done() // уменьшаем счетчик после завершения
        for n := range ch { // читаем из входного канала
            out <- n // отправляем в общий канал
        }
    }

    wg.Add(len(channels)) // добавляем задачу для каждого входного канала
    for _, ch := range channels {
        go output(ch) // запускаем горутину для каждого рабочего канала
    }

    // закрываем общий канал после завершения всех рабочих
    go func() {
        wg.Wait()
        close(out)
    }()

    return out
}

func main() {
    // Fan-Out: распределяем задачи между рабочими
    input := generator(10) // генерируем числа 1-10
    numWorkers := 3        // количество рабочих горутин
    workers := make([]<-chan int, numWorkers)

    // запускаем рабочих, каждый получает данные из общего канала
    for i := 0; i < numWorkers; i++ {
        workers[i] = squareWorker(i+1, input)
    }

    // Fan-In: собираем результаты от всех рабочих
    resultChan := fanIn(workers...)

    // суммируем результаты
    sum := 0
    for result := range resultChan {
        sum += result
    }
    fmt.Println("Итоговая сумма квадратов:", sum) // ожидаем 385 (1^2 + 2^2 + ... + 10^2)
}
```

##### Вывод (примерный)
```text
Рабочий 1: 1 -> 1
Рабочий 2: 2 -> 4
Рабочий 3: 3 -> 9
Рабочий 1: 4 -> 16
Рабочий 2: 5 -> 25
Рабочий 3: 6 -> 36
Рабочий 1: 7 -> 49
Рабочий 2: 8 -> 64
Рабочий 3: 9 -> 81
Рабочий 1: 10 -> 100
Итоговая сумма квадратов: 385
```

---
### Как это работает?

- **Fan-Out**:
    - generator отправляет числа в канал input.
    - Три squareWorker читают из этого канала конкурентно (распределение задач).
    - Каждый рабочий возводит числа в квадрат и отправляет результат в свой канал.
- **Fan-In**:
    - fanIn принимает каналы от рабочих и объединяет их в один канал resultChan.
    - Используется WaitGroup, чтобы дождаться завершения всех рабочих и закрыть общий канал.
- **Почему каналы?**:
    - Каналы обеспечивают безопасную передачу данных между горутинами.
    - Буферизация (make(chan int, max)) предотвращает блокировку при генерации.

---
### Лучшие практики

1. **Буферизация каналов**: Используйте буферы, если рабочие медленные, чтобы избежать заторов (например, `make(chan int, 10)`).
2. **Ограничение рабочих**: Не создавайте слишком много горутин — учитывайте ресурсы CPU.
3. **Закрытие каналов**: Всегда закрывайте каналы (`defer close`) для корректного завершения.
4. **Обработка ошибок**: Добавляйте каналы ошибок для передачи исключений 
	(например, `chan error`).
5. **Мониторинг**: Логируйте или используйте метрики для анализа производительности рабочих.
##### Расширенный пример с ошибками
```go
type Result struct {
    Value int
    Err   error
}

func squareWorkerWithError(id int, in <-chan int) <-chan Result {
    out := make(chan Result)
    go func() {
        defer close(out)
        for num := range in {
            if num == 5 { // имитация ошибки
                out <- Result{Err: fmt.Errorf("ошибка на %d у рабочего %d", num, id)}
                continue
            }
            out <- Result{Value: num * num, Err: nil}
        }
    }()
    return out
}
```

---
### Итог

- **Fan-Out**: Распределяет задачи от одного источника к нескольким рабочим через каналы.
- **Fan-In**: Собирает результаты от нескольких рабочих в один поток.
- Вместе они создают эффективный конвейер для параллельной обработки данных, как в примере с вычислением квадратов. Это удобно для задач с независимыми подзадачами (обработка файлов, запросы).

-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
