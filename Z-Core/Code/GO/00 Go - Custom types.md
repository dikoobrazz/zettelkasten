2025012919:34
___
Date: 29-01-2025 | 19:34
Tags: #go #types #custom
mapofcontents: 
___
## Custom Types

### Пользовательские типы

В Go можно создавать свои типы, чтобы сделать код более читаемым и структурированным. Для этого используется ключевое слово `type`.

## Зачем создавать собственные типы, если есть стандартные?

1. **Читаемость и ясность кода** Когда вы создаете новый тип на основе существующего типа (например, `int`, `string` и т. д.), вы добавляете смысл этому типу. В реальной жизни, например, число может означать не просто «целое число», а «возраст», «цена» или «количество». Использование собственных типов позволяет улучшить читаемость кода.

```go
type Age int
type Price float64
type UserID int

var age Age = 25
var price Price = 199.99
var userID UserID = 1001
```

В таком коде сразу видно, что `age` — это возраст, а не просто число, `price` — это цена, а `userID` — идентификатор пользователя. Это помогает избегать путаницы.

2. **Безопасность и типизация** Go — это строго типизированный язык. Создание собственных типов улучшает безопасность и помогает избежать ошибок. Например, вы можете передавать функции значения одного типа и быть уверены, что другой тип не будет случайно использован.

```go
type Age int

func (a Age) CanDrink() bool {
    return a >= 21
}

var age Age = 20
fmt.Println(age.CanDrink()) // false

// Нельзя передать в эту функцию тип Price, так как он не имеет метода CanDrink
```

В этом примере, если бы мы пытались передать в `CanDrink` тип `Price` или другой тип, который не имеет метода `CanDrink`, компилятор Go сразу бы сообщил об ошибке.

3. **Методы и поведение** Когда вы создаете новый тип, вы можете прикреплять к нему методы, которые логически связаны с этим типом. Это позволяет вам писать более чистый, организованный и повторно используемый код.

```go
type Point struct {
    X, Y int
}

// Метод для структуры Point
func (p Point) DistanceTo(other Point) float64 {
    return math.Sqrt(float64((p.X-other.X)*(p.X-other.X) + (p.Y-other.Y)*(p.Y-other.Y)))
}

func main() {
    p1 := Point{X: 3, Y: 4}
    p2 := Point{X: 7, Y: 1}
    fmt.Println(p1.DistanceTo(p2)) // 5
}
```

В этом примере структура `Point` имеет метод `DistanceTo`, который вычисляет расстояние между двумя точками. Это логичное поведение для типа `Point`.

4. **Инкапсуляция** Используя пользовательские типы, вы можете скрыть детали реализации, что помогает абстрагировать логику и защищать внутреннее состояние. Это особенно полезно, когда код масштабируется или когда вы хотите контролировать изменения.

```go
type Balance struct {
    amount float64
}

// Метод для изменения баланса
func (b *Balance) Deposit(amount float64) {
    if amount < 0 {
        fmt.Println("Недопустимая сумма для пополнения")
        return
    }
    b.amount += amount
}

// Метод для получения баланса
func (b Balance) GetBalance() float64 {
    return b.amount
}

func main() {
    balance := Balance{}
    balance.Deposit(100)
    fmt.Println(balance.GetBalance()) // 100
}
```

Здесь скрыта логика баланса, и код, использующий `Balance`, не имеет доступа напрямую к полю `amount`, а взаимодействует только через методы.

-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
