662024113020:14
___
Date: 30-11-2024 | 20:14
Tags: #go #array #slice 
mapofcontents: 
___
## [[00 Массив|Массивы]]. Срезы. Задачи

> **[[00 Массив|Массив]]** — это последовательность элементов одного типа фиксированной длины. Объявление массива осуществляется следующим образом:

```Go
var a [3]int
fmt.Println(a) // [0 0 0]

var a [3]int = [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [...]int{1, 2, 3}
d := [3]int{1: 12}

fmt.Println(a) // [1 2 3]
fmt.Println(b) // [1 2 3]
fmt.Println(c) // [1 2 3]
fmt.Println(d) // [0 12 0]
```

> Нужно учитывать, что сравнимы только массивы одного типа (массивы одинаковой длины, содержащие элементы одинакового типа).

```Go
a := [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [3]int{3, 2, 1}

fmt.Println(a == b) // true
fmt.Println(a == c) // false
```

## [[00 Срез|Срезы]] (слайсы, slices)

> **[[00 Срез|Срез]]** — это последовательность элементов одного типа переменной длины.

>[!info] INFO 
>Массивы и срезы тесно связаны. Срез — это структура данных, которая предоставляет доступ к подпоследовательности элементов базового массива. Длину массива изменять нельзя, а вот новые элементы в срез добавлять можно, так что в некоторых языках срезами называются динамические массивы.

**[[00 Срез|Срез]]** состоит из трех компонентов: указателя, длины и емкости:
- указатель указывает на первый элемент массива, доступный через срез (который не обязательно совпадает с первым элементом массива);
- **длина (length)** — это количество элементов среза;
- **емкость (capacity)** - количество элементов между началом среза и концом базового массива.

Длина и емкость среза могут быть определены при помощи встроенных функций **len()** и **cap()** соответственно.

### Создание пустого среза

> [!info] INFO 
> Пустой срез может быть создан аналогично созданию массива за тем исключением, что нам нет необходимости указывать длину среза, поскольку она изменяема. При создании пустого среза мы также можем инициализировать его, явно указав элементы среза.

```Go
var a []int
var b []int = []int{1, 2, 3}
c := []int{1, 2, 3}
d := []int{1: 12}

fmt.Println(a) // []
fmt.Println(b) // [1 2 3]
fmt.Println(c) // [1 2 3]
fmt.Println(d) // [0 12]
```

> Для гибкого способа создания пустых **[[00 Срез|срезов]]** в Go существует встроенная функция make следующего вида: `make([]T, length, capacity)`

Go создает **[[00 Массив|массив]]** какой-то длины. Указатель среза будет указывать на первый элемент созданного **[[00 Массив|массива]]**, длина **[[00 Срез|среза]]** составит 0 (если мы явно не указали элементы среза), емкость необходимого массива будет определена Go самостоятельно.

Для чего нам может потребоваться явно указать длину и емкость среза:

- для того, чтобы инициализировать нулевыми значениями элементы массива (длина среза);
- для того, чтобы выделить нужное количество памяти для хранения массива, лежащего в основе нашего среза.

```go
a := make([]int, 10, 10) // [0 0 0 0 0 0 0 0 0 0]
fmt.Println(a)
```

#### Использование append для удаления элемента из среза

В Go отсутствует встроенная функция для удаления элемента из среза, но мы можем воспользоваться функцией append для того, чтобы создать новый срез, включающий в себя срез элементов до игнорируемого элемента, а также все элементы после игнорируемого:

```Go
a := []int{1, 2, 3, 4, 5, 6, 7}
a = append(a[0:2], a[3:]...)
fmt.Println(a) // [1 2 4 5 6 7]
```

>[!info] INFO
>_В этом примере встречается символ ... после указания на передачу среза в качестве аргумента._
>_Такое использование многоточия означает раскрытие среза (его элементы передаются функции append как отдельные аргументы)._

### Особенности работы со срезами

**[[00 Срез|Cрез]]** по своей сути - указатель на массив, а это влияет на его поведение при передаче в качестве аргумента в функцию:

```Go
func fnA(a [3]int) {
	a[1] = 15
}

func fnB(a []int) {
	a[1] = 15
}

func main() {
	a := [3]int{1, 2, 3}
	b := []int{1, 2, 3}

	fnA(a)
	fnB(b)

	fmt.Println(a) // [1 2 3]
	fmt.Println(b) // [1 15 3]
}
```

В приведенном примере мы создали 2 функции: fnA и fnB. Первая получает в качестве аргумента **[[00 Массив|массив]]** из 3-х элементов, вторая - **[[00 Срез|срез]]**. Обе функции изменяют второй элемент последовательности, но мы получаем совсем разный результат, потому что fnB работала с указателем на массив и изменила непосредственно сам массив, fnA же работала с копией массива, поэтому внутри функции был изменен элемент копии массива, а базовый массив остался неизменен.

-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
- [[00 Массив]]
- [[00 Срез]]
------
**Links** (Внешние ссылки)
-
