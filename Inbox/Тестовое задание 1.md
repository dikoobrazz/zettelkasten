
**Техническое задание:** Разработка сервиса управления задачами с аналитикой
**Цель:** Разработать веб-приложение для управления задачами с расширенными функциями аналитики. 

## Функциональные требования

1. **Управление задачами:**
	- Пользователь может:
		- Добавить новую задачу с полями:
			`id` (уникальный идентификатор).
			`title` (название задачи).
			`description` (опционально).
			`status` (pending, in_progress, done).
			`priority` (low, medium, high).
			`due_date` (дата завершения).
			`created_at` (дата создания, автоматически).
			`updated_at` (дата обновления, автоматически).
		- Редактировать задачи.
		- Удалять задачи.
	- Автоматическое удаление задач, просроченных на 7 дней.
	
2. **Фильтрация и поиск:**
	- Возможность фильтровать задачи по:
		- Статусу.
		- Приоритету.
		- Дате завершения.
	-  Поиск задач по названию.
	
3. **Аналитика:**
	- Подсчет:
		- Количества задач в каждом статусе.
		- Среднего времени выполнения задач.
	- Генерация отчета за последние 7 дней:
		- Количество завершенных задач.
		- Количество просроченных задач.
		
4. **Авторизация и аутентификация:**
	- JWT-аутентификация.
	- Регистрация и вход для пользователя.
	
5. **Импорт/экспорт задач:**
	- Экспорт всех задач в формате JSON.
	- Импорт задач из файла JSON.

## Технические требования. 

1. **Язык программирования:** Golang.
2. **База данных:** PostgreSQL.
3. **Архитектура:**
	- Применение паттерна *Clean Architecture*.
4. **Инфраструктура:**
	- Приложение должно быть завернуто в **Docker**-контейнер.
	- Использовать `docker-compose` для запуска:
		- Приложения.
		- **PostgreSQL**.
	- **Redis** для кэширования аналитики.
5. **API:**
	- Реализовать REST API с использованием фреймворка (например, Gin):
		- **`POST /auth/register`** — регистрация пользователя.
		- **`POST /auth/login`** — вход и получение JWT.
		- **`GET /tasks`** — получение списка задач с фильтрацией и поиском.
		- **`POST /tasks`** — добавление задачи.
		- **`PUT /tasks/:id`** — обновление задачи.
		- **`DELETE /tasks/:id`** — удаление задачи.
		- **`GET /analytics`** — получение аналитики.
		- **`POST /tasks/import`** — импорт задач из JSON.
		- **`GET /tasks/export`** — экспорт задач в JSON.
6. **Асинхронность:**
	- Использовать горутины для:
		- Удаления устаревших задач (каждые 24 часа).
		- Генерации аналитики (раз в 6 часов).
	- Использовать каналы и мьютексы для синхронизации данных.
7. **Тесты:**
	- Покрытие unit-тестами следующих компонентов:
		- CRUD-операции с задачами.
		- Аналитика.
	- Интеграционные тесты для API.

## Что предоставить

1. Исходный код проекта.
2. **README.md** с инструкциями:
	- Как запустить приложение через docker-compose .
	- Примеры API-запросов (curl или Postman).
3. **SQL**-скрипты или миграции для базы данных.
4. Пример файла **JSON** для импорта/экспорта задач.
5. **Swagger**-документацию для API.

## Критерии оценки

1. **Код и архитектура:**
	- Чистота и читаемость кода.
	- Применение Clean Architecture.
2. **API:**
	- Корректность работы всех запросов.
	- Наличие фильтров и поиска.
3. **Асинхронность и производительность:**
	- Реализация периодических задач.
	- Использование кэширования (**Redis**).
4. **Документация:**
	- Понятные инструкции по запуску.
	- Полная API-документация.
5. **Тестирование:**
	- Покрытие ключевых модулей тестами.

## Дополнительно

- Логирование (slog или logrus).
- Поддержка локализации (например, для полей `priority` ).
- Мониторинг приложения (Prometheus + Grafana).

---
# Task Management API


RESTful API-сервис для управления задачами, разработанный с использованием Go 1.24 и принципов чистой архитектуры.

## Особенности

- REST API с использованием фреймворка Gin и стандартной библиотеки Go 1.24
- Аутентификация на основе JWT
- Управление задачами (создание, чтение, обновление, удаление)
- Фильтрация и поиск задач
- Импорт и экспорт задач
- Генерация аналитики по задачам
- Swagger документация API
## Требования

- Go 1.24 или выше
- PostgreSQL 14 или выше
- Redis для кэширования (опционально)

## Установка и запуск

1. Клонируйте репозиторий:

```

git clone github.com/jmoloko/cursorai/project

cd project

```

2. Создайте файл .env на основе примера:

```

cp .env.example .env

```

3. Настройте переменные окружения в файле .env

4. Создайте базу данных:

```

createdb taskmanager

```

5. Примените миграции:

```

psql -d taskmanager -f migrations/001_init.sql

```

6. Соберите и запустите приложение:

```

go build -o taskmanager ./cmd/app

./taskmanager

```

7. Или используйте Docker Compose:

```

docker-compose up -d

```

## Архитектура

Проект следует принципам чистой архитектуры (Clean Architecture):

- **Домен** (domain) - бизнес-модели и интерфейсы репозиториев
- **Репозитории** (repository) - реализации для работы с базой данных
- **Сервисы** (service) - бизнес-логика приложения
- **Обработчики** (handler) - HTTP-обработчики запросов
- **Middlewares** - промежуточные обработчики для HTTP-запросов

Ключевые принципы, которые были применены:
- Разделение на слои
- Инверсия зависимостей
- Принцип разделения интерфейсов (ISP)
- Единая ответственность (SRP)
- 
## API Endpoints

Полная документация API доступна через Swagger UI по адресу `/swagger/index.html` после запуска приложения.

### Аутентификация

- `POST /auth/register` - Регистрация нового пользователя
- `POST /auth/login` - Аутентификация и получение JWT-токена

### Задачи

- `GET /tasks` - Получение списка задач с фильтрацией
- `POST /tasks` - Создание новой задачи
- `GET /tasks/{id}` - Получение задачи по ID
- `PUT /tasks/{id}` - Обновление задачи
- `DELETE /tasks/{id}` - Удаление задачи

### Импорт/Экспорт
  
- `GET /tasks/export` - Экспорт всех задач пользователя
- `POST /tasks/import` - Импорт задач
  
### Аналитика

- `GET /analytics?period=week` - Получение аналитики по задачам

## Структура проекта

```
.
├── cmd/ # Точки входа в приложение
│ └── app/ # Основное приложение
├── docs/ # Документация, включая Swagger
├── internal/ # Внутренний код приложения
│ ├── config/ # Конфигурация
│ ├── domain/ # Бизнес-модели и интерфейсы
│ │ ├── models/ # Бизнес-модели
│ │ └── repository/ # Интерфейсы репозиториев
│ ├── handler/ # HTTP-обработчики
│ ├── middleware/ # HTTP-middleware
│ ├── logger/ # Логирование (с поддержкой slog)
│ ├── repository/ # Реализации репозиториев
│ │ └── postgres/ # PostgreSQL репозитории
│ ├── server/ # HTTP-сервер
│ └── service/ # Бизнес-логика
├── migrations/ # SQL-миграции
├── .env # Переменные окружения
└── .env.example # Пример файла с переменными окружения
```

## Примеры использования

### Регистрация пользователя

```bash

curl -X POST http://localhost:8080/auth/register \

-H "Content-Type: application/json" \

-d '{"email":"user@example.com","password":"password123"}'

```

### Аутентификация и получение токена

```bash

curl -X POST http://localhost:8080/auth/login \

-H "Content-Type: application/json" \

-d '{"email":"user@example.com","password":"password123"}'

```

### Создание задачи

```bash

curl -X POST http://localhost:8080/tasks \

-H "Content-Type: application/json" \

-H "Authorization: Bearer <your-token>" \

-d '{"title":"Важная задача","description":"Описание задачи","priority":"high","due_date":"2023-12-31T23:59:59Z"}'

```

## Тестирование

Для запуска тестов:

```bash

go test ./...

```

## Swagger документация

Swagger документация доступна по адресу `/swagger/index.html` после запуска приложения.

Документация была сгенерирована с использованием аннотаций в коде и доступна в формате YAML в файле `docs/swagger.yaml`.

---





Ты лучший разработчик на языке Go!  
Ты написал данное приложение.  
Тебе нужно протестировать работу приложения, а именно:  
- Фильтрация и поиск:  
- Фильтрация задачи по:  
- Статусу  
- Приоритету  
- Дате завершения  
- Поиск задачи по названию  
- Аналитика:  
- Подсчёт количества задач в каждом статусе  
- Подсчёт среднего времени выполнения задачи  
- Генерация очёта за последние 7 дней:  
- Количество завершённых задач  
- Количество просроченных задач  
- Redis , как он кэширует аналитику  
- использование горутин для:  
- удаление устаревших задач (каждые 24 часа)  
- генерация аналитики (раз в 6 часов)  
Не забывай - ты профессионал в Go.  
Очень подробно анализируй свой код перед каждым действием!  
После анализа, думай как проверить описанную функциональность.  
Не торопись, будь рассудительным. Будь профессионалом в своём деле!

Не торопись, подробно проанализируй код. Перед действием. Будь профи!  
При добавлении фоновых задач:  
- Автоматического удаления просроченных задач (каждые 24 часа)  
- Автоматической генерации аналитики (каждые 6 часов)  
Используй асинхронность (главную фичу языка Go). Используй каналы и мьютексы!  
Будь аккуратен и вдумчив, не делай поспешных выводов. Пиши код кратко, не раздувая по возможности

  
Прежде чем приступить к рефакторингу, детально просмотри файлы которые будут отредактированны (изменены), заранее тщательно обдумай все свои действия, чтобы не сломать уже работающий код (это самое главное!).  
После того как ты всё проанализируешь и обдумаешь, наметь план рефакторинга, распиши все шаги и только потом начинай действовать не отходя от намеченного плана. Будут возникить linter error, которые тебе нужно будет исправить после рефактора.  
Действуй как tech leader Go! И помни главное - не сломать работающий код!


Прежде чем приступить к написанию тестов, детально просмотри файлы которые будут тестироваться, заранее тщательно обдумай все свои действия, обдумай что нужно протестировать и как это реализовать
После того как ты всё проанализируешь и обдумаешь, наметь план, распиши все шаги и только потом начинай действовать не отходя от намеченного плана.
Действуй как tech leader Go!


Теперь пришло время покрыть unit-тестами следующие компоненты: 
- CRUD-операции с задачами. 
- Аналитика.  
Прежде чем приступить к написанию тестов, детально просмотри файлы которые будут тестироваться, заранее тщательно обдумай все свои действия, обдумай что нужно протестировать и как это реализовать  
После того как ты всё проанализируешь и обдумаешь, наметь план, распиши все шаги и только потом начинай действовать не отходя от намеченного плана.  
Иди шаг за шагом. НЕ ПИШИ СРАЗУ ВЕСЬ ФАЙЛ ...test.go. Пиши и тестируй пошагово по одной функции за один раз. Как только тест пройден, приступай к следующей тестируемой функции(методу) и так шаг за шагом. Не пытайся объять всё сразу. Будь последовательным и внимательным.
Действуй как tech leader Go!

Ты Tech Leader Golang!
Очень подробно анализируй свой код перед каждым действием!  
Преред написанием новой функциональности (кода), детально изучи requirements.md или предоставленное техническое задание.
Подробно изучи уже существующую кодовую базу приложения!
Тщательно проанализируй полученную информацию, контекст рабочей задачи и составь пошаговый план дальнейшей работы!
Как только план действий готов, приступай к реализации описанных пунктов, шаг за шагом!
Не пытайся сделать всё сразу. Будь последовательным и внимательным!
Всегда сверяйся с контекстом приложения и кодовой базой!
Действуй как Tech Leader Go!
При написании кода, тестов, etc... всегда следуй принципу Clean Architecture, SOLID, best-practicie, Ты профессионал!