2024121116:26
___
Date: 11-12-2024 | 16:26
Tags: #git #github
mapofcontents: [[zero-links|OO Links]]
___
## Git Totorial

### Commands

**Commands**
- `git init` - инициализация репозитория
- `git add .` - добавить в отслеживание (tracked) все файлы и папки
- `git commit -m "init repository"` - создание коммита 
- `git status` - показывает отслеживаемые и не отслеживаемые файлы|папки
- `git log` - выводит список коммитов в ветке
- `git diff --staged` - просмотр изменений в не закомиченных файлах
- `git remote add origin https://github.com/dikoobrazz/test.git` - указываем где находится удалённый репозиторий (откуда принимать и с чем актуализировать)
- `git branch -M main` - выставляет ветку **main** - главной веткой
	- можно оставить как есть - **master**
- `git push -u origin master` || `git push -u origin main` - пушим в удалённый репозиторий 
- `git push` - дальнейшее добавление в удалённый репо в ветку по умолчанию (master || main)
- 
- `.gitignore` - файл с исключениями для отслеживания
- `empty-folder/.gitkeep` - добавляем в пустую папку файл `.gitkeep`, что бы запушить пустую папку

**Branches Ветки**
 * `git checkout -b new-branch` - создание и переход на новую ветку `new-branch`
 * `git push --set-upstream origin new-branch` - пушим в новую ветку. Нужно указать `upstream`, потому что данная ветка ещё не существует на удалённом репо. 
	`--set-upstream` - указываем только при первом пуше.
 * `git checkout master` - переход на ветку **master**
 * `git checkout README.md main.go` - откатит изменения в этих не закомиченных файлах.
 * `git merge new-branch` - мержим `new-branch` в `master` (объеденяем две ветки)
 * `git push` - пушим в удалённый репо объединённые ветки
 * `git branch -D new-branch` - удаляем ветку `new-branch` локально!!!
 * `git push --delete origin new-branch` - удаляем ветку `new-branch` на удалённом репо
 * `cherry-pick` - нужна для копирования одоного или нескольких коммитов из одной ветки в другую. От `merge` - отличается тем, что перенос более точечный. При `merge` - в ветке окажутся все коммиты, а при `cherry-pick` - только те, что мы укажем.
	`master#~> git cherry-pick 3498f9dg92f9sdf9s8d6f938f9as8df` - перенос коммита в ветку `master` по тэгу коммита из другой ветки
- `git stash` - позволяет временно сохранить не закоммиченный код в кэш.
- `git stash pop` - возвращаем данные из кэша
- `git reset --hard` - вернёт к начальному состояню (до изменения) все не закомиченные данные, те вернёт состояние файлов до изменения
- `git reset --hard 3498f9dg92f9sdf9s8d6f938f9as8df` - откат до нужного коммита, всё остальное удаляется.
- `git reset --soft 3498f9dg92f9sdf9s8d6f938f9as8df` - откат до нужного коммита, все остальное останется.
- `git revert 3498f9dg92f9sdf9s8d6f938f9as8df` - откат до указанного коммита
- `git rebase new-branch` - типа `merge`, но ОПАСНО! Интегрирует коммиты в текущую ветку, а не наложит их сверху как при `merge`. rebase - поменяе саму структуру ветки и историю коммитов.
- `commit amend` - команда для изменения коммитов
  `git commit --amend` - позволяет добавить код в рамках предыдущего коммита + изменить название
  `git commit --amend --no-edit` - оставит у коммита прошлое название
- `git push -f`||`git push force` - при ситуации, когда мы модифицируем коммиты, которые уже есть на удалённой ветке (тот же конфликт). Здесь мы перезатираем историю коммитов
- `git log --all --graph` - показывает историю коммитов в виде графа
- **tig** - консольная утилита для просмотра истории веток и коммитов
- `git rebase -i HEAD~3` - работа сразу с тремя последними коммитами

`pick` - оставить коммит
![[_resources/rebase-i.png]]
`d` - удалить, `s` - объединение 2го коммита с первым, `r`- переименовать коммит
![[_resources/rebase-i_2.png]]
переименование коммита
![[_resources/rebase-i_3.png]]

**Merge Conflicts** _(конфликт слияния)_ 
- ...

**Merge Request | Pull Request**
- `git pull` - подгружаем актуальные данные с удалённого репо


-----
**Zero-Links**  (Внутренние ссылки) Линки - ключевые слова
-

------
**Links** (Внешние ссылки)
-
