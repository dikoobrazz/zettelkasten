2023082715:31
___
Tags: #code #ozon #contest
___
# Contest Route-256 OZON

### Task-b (10)

Для отслеживания посылок компания NOZO использует наклейки с надписями. Иногда надпись (или её часть) на наклейке нужно исправить, и тогда поверх старой наклейки лепят новую.

На очередной посылке появилось слишком много наклеек и теперь невозможно прочитать наклеенную надпись целиком.

Помогите это сделать по истории этих наклеек.

**Входные данные:**
Первая строка s представляет собой содержимое изначальной наклейки. Гарантируется, что её длина не превышает 1000 символов.

Во второй строке записано целое число n (1≤n≤1000), обозначающее количество наклеенных поверх наклеек.

Далее идёт n строк, каждая из которых описывает очередную наклейку в порядке её применения: от самой старой к самой новой. Каждое описание содержит два числа starti и endi (1≤start≤end≤|s|, где |s| обозначает длину строки s) и через пробел строку ri, которая была записана поверх символов между starti и endi. Гарантируется, что длина строки ri точно равна end−start+1. Эта запись обозначает, что поверх всех символов, начиная с символа под номером start и заканчивая символом под номером end, была наклеена строка ri.

Гарантируется, что все строки состоят только из строчных латинских букв.

**Выходные данные:**
Выведите итоговую строку, которая видна после применения всех наклеек.

**Примеры:**

==Входные данные==
somesuperlongstring
3
1 2 la
4 4 d
10 13 tiny
==Выходные данные==
lamdsupertinystring

==Входные данные==
somesuperlongstring
4
1 2 la
4 4 d
10 13 tiny
4 5 ed
==Выходные данные==
lamedupertinystring


### Task-C (10)

В офисе стоит кондиционер, на котором можно установить температуру от 15 до 30 градусов.

В офис по очереди приходят n сотрудников. i-й из них желает температуру не больше или не меньше ai.

После прихода каждого сотрудника определите, можно ли выставить температуру, которая удовлетворит всех в офисе.

**Входные данные:**
Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит целое число t (1≤t≤103) — количество наборов входных данных. Далее следует описание наборов входных данных.

Первая строка каждого набора содержит целое число n (1≤n≤103) — количество сотрудников.

i-я из следующих n строк каждого набора входных данных содержит требование к температуре от i-го сотрудника: либо ≥ai, либо ≤ai (15≤ai≤30, ai — целое число). Требование ≥ai означает, что i-й сотрудник желает температуру не ниже ai; требование ≤ai означает, что i-й сотрудник желает температуру не выше ai.

Гарантируется, что сумма n по всем наборам входных данных не превосходит 103.

**Выходные данные:**
Для каждого набора входных данных выведите n строк, i-я из которых содержит температуру, удовлетворяющую всех сотрудников с номерами от 1 до i включительно. Если такой температуры не существует, выведите −1. После вывода ответа на очередной набор входных данных выводите пустую строку.

Если ответов несколько, выведите любой.

**Пример**

==Входные данные==
4
1
>= 30
6
>= 18
<= 23
>= 20
<= 27
<= 21
>= 28
3
<= 25
>= 20
>= 25
3
<= 15
>= 30
<= 24

==Выходные данные==
30

29
19
22
21
20
-1

23
22
25

15
-1
-1

**Примечание**

Пояснение к первому примеру:

1. добавляется требование ≥30  диапазон возможных температур — [30, 30], поэтому единственный возможный ответ — 30 градусов.

Пояснение ко второму примеру:

1. добавляется требование ≥18, диапазон возможных температур — [18, 30], поэтому в rачестве примера взяли 29 градусов;
2. добавляется требование ≤23, диапазон возможных температур — [18, 23], поэтому в качестве примера взяли 19 градусов;
3. добавляется требование ≥20, диапазон возможных температур — [20, 23], поэтому в качестве примера взяли 22 градуса;
4. добавляется требование ≤27, диапазон возможных температур — [20, 23], поэтому в качестве примера взяли 21 градус;
5. добавляется требование ≤21, диапазон возможных температур — [20, 21], поэтому в качестве примера взяли 20 градусов;
6. добавляется требование ≥28, диапазон возможных температур — [28, 21], поэтому ответа нет и нужно вывести -1.

Пояснение к третьему примеру:

1. добавляется требование ≤25, диапазон возможных температур — [15, 25], поэтому в качестве примера взяли 23 градуса;
2. добавляется требование ≥20, диапазон возможных температур — [20, 25], поэтому в качестве примера взяли 22 градуса;
3. добавляется требование ≥25, диапазон возможных температур — [25, 25], поэтому в качестве примера можно взять только 25 градусов.

Пояснение к четвертому примеру:

1. добавляется требование ≤15, диапазон возможных температур — [15, 15], поэтому в качестве примера можно взять только 15 градусов;
2. добавляется требование ≥30, диапазон возможных температур — [30, 15], поэтому ответа нет и нужно вывести -1;
3. добавляется требование ≤24, диапазон возможных температур — [30, 15], поэтому ответа нет и нужно вывести -1.

### Task-D (15)

Назовём рельефом гор 2D-изображение из n строк и m столбцов, состоящее только из символов 'X', '.' (точка), '/' (прямой слеш) и '\' (обратный слеш). Изображение составлено по следующим формальным правилам:

- либо непосредственно слева снизу от символа '/' находится такой же символ, либо непосредственно слева от символа '/' находится символ '\', либо символ '/' находится на нижней строке;
- либо непосредственно справа сверху от символа '/' находится такой же символ, либо непосредственно справа от символа '/' находится символ '\';
- либо непосредственно слева сверху от символа '\' находится такой же символ, либо непосредственно слева от символа '\' находится символ '/';
- либо непосредственно справа снизу от символа '\' находится такой же символ, либо непосредственно справа от символа '\' находится символ '/', либо символ '\' находится на нижней строке;
- каждый столбец содержит не более одного из символов '/' и '\';
- в каждом столбце все символы ниже '/' и '\' равны 'X';
- все остальные символы равны '.'.

Все символы, кроме '.', являются частью горы.

В каждом рельефе гор есть хотя бы один символ, не равный '.'.

Дано k рельефов по их близости к наблюдателю: от ближних к дальним. Выведите рельеф, видный наблюдателю. Если в некотором рельефе символ в x-й строке и y-м столбце является частью горы, то во всех более дальних от наблюдателя рельефах гор символы на этой позиции не видны наблюдателю.

**Входные данные**
Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит целое число t (1≤t≤20) — количество наборов входных данных. Далее следует описание наборов входных данных.

Первая строка каждого набора содержит три целых числа k, n и m (1≤k,n≤20, 2≤m≤20) — количество рельефов, высоту и ширину ASCII-арта.

Далее следуют описания k рельефов гор.

Описание рельефа гор состоит из n строк, по m символов в каждой — сам ASCII-арт.

Описания рельефов разделены пустой строкой.

**Выходные данные**
Для каждого набора входных данных выведите в n строках рельеф гор, видный наблюдателю. После ответа на каждый набор входных данных выведите пустую строку.

![[_resources/2023-08-27_15-51.png]]

### Task-E (20)

Среди ваших n друзей стало популярно коллекционирование редчайших карточек. Производитель выпустил m различных видов карточек, пронумерованных от 1 до m. Эти карточки настолько редкие, что их продает только один человек. Известно, что у него осталось всего m карточек, по одной каждого вида.

Вам известно, что у i-го из ваших друзей есть все карточки с номерами от 1 до ai включительно. Вы хотите сделать подарок всем своим друзьям, подарив i-му из них карточку bi, которой у него еще нет, то есть такую, что bi>ai.

**Входные данные**
Первая строка содержит два целых числа n и m (1≤n,m≤105) — количество друзей и количество карточек.

Вторая строка содержит n целых чисел ai (1≤ai≤m).

Решения, работающие правильно при n,m≤100, получат 10 баллов.

**Выходные данные**
Выведите массив bi или −1, если ответа не существует. Если ответов несколько, выведите любой.

**Примеры**

==Входные данные==
5 7
3 3 2 6 5
==Выходные данные==
5 4 3 7 6

==Входные данные==
4 4
2 1 2 2
==Выходные данные==
-1

==Входные данные==
5 6
3 1 2 3 5
==Выходные данные==
4 2 3 5 6

**Примечание**

Пояснение к первому примеру:

У нас есть 5 друзей и 7 различных карточек.

1. Мы дарим 1 другу — 5 карточку, так как ее у него еще нет. Пока неподаренными остались карточки [1, 2, 3, 4, 6, 7].
2. Мы дарим 2 другу — 4 карточку, так как ее у него еще нет. Пока неподаренными остались карточки [1, 2, 3, 6, 7].
3. Мы дарим 3 другу — 3 карточку, так как ее у него еще нет. Пока неподаренными остались карточки [1, 2, 6, 7].
4. Мы дарим 4 другу — 7 карточку, так как ее у него еще нет. Пока неподаренными остались карточки [1, 2, 6].
5. Мы дарим 5 другу — 6 карточку, так как ее у него еще нет. Пока неподаренными остались карточки [1, 2].

Также возможны и другие варианты раздачи карточек.

Во втором тесте никак нельзя выдать карточки правильно, поэтому и ответ — -1.

### Task-F (25)

На маркетплейсе у каждого товара есть категория. При этом, у некоторых категорий есть дочерние категории. Для удобной навигации по маркетплейсу покупатели могут пользоваться деревом категорий.

![[_resources/2023-08-27_15-59.png]]

Ваша задача — построить дерево категорий. Дана информация об отношениях родительских и дочерних категорий в виде JSON-массива. Каждый элемент массива является словарем, с полями name (название категории), id (числовой идентификатор категории) и parent (числовой идентификатор родительской категории). Известно, что корневая категория имеет нулевой идентификатор и не имеет идентификатора родительской категории.

По данной информации постройте дерево категорий в виде JSON-словаря. Словарь для каждой категории должен иметь поля name, id и массив next, состоящий из таких же словарей для дочерних категорий.

**Входные данные**

Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит целое число t (1≤t≤100) — количество наборов входных данных. Далее следует описание наборов входных данных.

Первая строка каждого набора входных данных содержит целое число n (1≤n≤1000) — количество строк с описанием JSON-массива категорий.

Следующие n строк содержат описание JSON-массива категорий. Все числовые идентификаторы категорий являются целыми числами и удовлетворяют условию 0≤id≤109. Все имена категорий непустые, состоят из строчных латинских букв и имеют длину не больше 20. В описании могут быть символы пробела и табуляции.

Гарантируется, что каждый набор входных данных содержит корневую категорию и не более 400
категорий.

Гарантируется, что размер входных данных не превосходит 10Мб.

**Выходные данные**

Выведите JSON-массив из t элементов. i-й элемент массива является словарем с описанием дерева категорий для i-го набора входных данных. При проверке ответа пробелы, табы и переносы строки не учитываются(кроме таковых в json полях). Порядок полей в словаре и порядок дочерних категорий в массиве next не учитывается. Если у категории нет дочерних категорий, ключ next может отсутствовать, или соответствовать пустому массиву.

**Примеры**

==Входные данные==
```json
2
21
[
   {
     "id":0,
     "name":"all"
   },
   {
      "id":1,
      "name":"clothes",
      "parent":0
   },
   {
      "id":2,
      "name":"shoes",
      "parent":0
   },
   {
      "id":55,
      "name":"sneakers",
      "parent":2
   }
]
6
 [ {"parent":	0,"id":100,  "name":
 "x"},{

"name":"x","id":0}

]
```
==Выходные данные==
```json
[{
	"id": 0,
	"name": "all",
	"next": [{
		"id": 1,
		"name": "clothes",
		"next": []
	}, {
		"id": 2,
		"name": "shoes",
		"next": [{
			"id": 55,
			"name": "sneakers"
		}]
	}]
},
{"name":"x","id":0,"next":[{"id":100,"name":"x"}]}
]
```

==Входные данные==
```json
1
9
[
 {"name": "everything", "id": 0},
 {"name": "clothes", "id": 1, "parent": 0},
 {"name": "electronics", "id": 2, "parent": 0},
 {"name": "computers", "id": 4, "parent": 2},
 {"name": "aio", "id": 3, "parent": 4},
 {"name": "tv", "id": 5, "parent": 2},
 {"name": "house", "id": 6, "parent": 0}
]
```
==выходные данные==
```json
[
{"id":0,"name":"everything","next":[{"id":1,"name":"clothes","next":[]},{"id":2,"name":"electronics","next":[{"id":4,"name":"computers","next":[{"id":3,"name":"aio","next":[]}]},{"id":5,"name":"tv","next":[]}]},{"id":6,"name":"house","next":[]}]}
]
```

**Примечание**
Любые внешние библиотеки использовать нельзя.

- Для работы с JSON в языке C# можно пользоваться библиотекой [System.Text.Json](https://learn.microsoft.com/en-us/dotnet/api/system.text.json?view=net-7.0). Возможно, вам понадобится увеличить максимальную глубину сериализации/десериализации JSON ([документация](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.maxdepth?view=net-7.0)).
- Для работы с JSON в языке Go можно пользоваться библиотекой [encoding/json](https://pkg.go.dev/encoding/json).
- Для работы с JSON в языке Python можно пользоваться библиотекой [json](https://docs.python.org/3/library/json.html).

### Task-G (25)

Колода состоит из 52 карт. Каждая карта обозначается одним из тринадцати значений (2, 3, 4, 5, 6, 7, 8, 9, Ten, Jack, Queen, King, Ace) и одной из четырех мастей (Spades, Clubs, Diamonds, Hearts).

Выдуманная игра 3-Покер происходит следующим образом.

1. Изначально все n игроков получают по две карты из колоды.
2. После этого на стол выкладывается одна карта из той же колоды.
3. Выигрывают те игроки, у которых собралась самая старшая комбинация.

Для определения самой старшей комбинации, которая собралась у i-го игрока, используются следующие правила:

- если две карты у игрока в руке и карта на столе имеют одинаковое значение, игрок собрал комбинацию 'Сет со значением x';
- если из двух карт у игрока в руке и карты на столе можно выбрать две карты с одинаковым значением x, игрок собрал комбинацию 'Пара со значением x';
- иначе, берется карта с самым старшим значением из двух карт у игрока в руке и карты на столе, тогда игрок собрал комбинацию 'Старшая карта x'.

Любой сет старше пары, а любая пара старше комбинации старшая карта. Из одинаковых комбинаций старше та, у которой старше значение. Если одинаковая самая старшая комбинация есть у нескольких игроков, все они объявляются выигрывшими.

Вы — первый игрок. Вам известно, какие карты получил на руки каждый игрок. Определите, какую карту можно выложить на стол, чтобы вы оказались в числе победителей.

**Входные данные**
Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит целое число t (1≤t≤103) — количество наборов входных данных. Далее следует описание наборов входных данных.

Первая строка каждого набора входных данных содержит целое число n (2≤n≤25) — количество игроков.

Следующие n строк каждого набора входных данных содержат описания двух карт, разделенных пробелом — карты, которые получил на руки i-й игрок.

Описание карты состоит из двух символов, записанных подряд: значения и масти.

**Выходные данные**
Для каждого набора входных данных выведите в первой строке количество карт k, которые можно выложить на стол для вашей победы. В следующих k строках выведите описания этих карт. Выводить описания можно в любом порядке.

**Примеры**

==Входные данные==
4
2
TS TC
AD AH
3
2H 3H
9S 9C
4D QS
3
4C 7H
4H 4D
6S 6H
3
2S 3H
2C 2D
3C 3D
==Выходные данные==
2
TD
TH
0
3
7S
7C
7D
0

==Входные данные==
1
7
AS AC
AD AH
KS JH
9D 9C
5H 5D
3C 3S
TC TH
==Выходные данные==
30
2S
2C
2D
2H
4S
4C
4D
4H
6S
6C
6D
6H
7S
7C
7D
7H
8S
8C
8D
8H
JS
JC
JD
QS
QC
QD
QH
KC
KD
KH

### Task-H (30)

Дан черный список IP адресов. Все IP адреса принадлежат подсети 100.200.0.0/16, то есть имеют вид 100.200.X.Y для некоторых 0≤X,Y<256.

Вам нужно запретить доступ ко всем адресам из черного списка. Для этого можно создать фильтрующий файл. Каждая запись в файле имеет вид:

- 100.200.0.0/16 — эта запись запрещает доступ к подсети из 65536 адресов, то есть ко всем адресам, которые имеют вид 100.200.X.Y для некоторых 0≤X,Y<256;
- 100.200.X.0/24 (0≤X<256) — эта запись запрещает доступ к подсети из 256 адресов, то есть ко всем адресам, которые имеют вид 100.200.X.Y для некоторого 0≤Y<256;
- 100.200.X.Y (0≤X,Y<256) — эта запись запрещает доступ к указанному IP адресу.

Из-за технических ограничений в файле не может быть больше, чем k записей. Вам нужно составить фильтрующий файл так, чтобы доступ ко всем IP адресам из черного списка был запрещен. При этом, количество запрещенных IP адресов не из черного списка должно быть минимально.

**Входные данные**
Первая строка содержит два целых числа n и k (1≤n,k≤65536) — размер черного списка IP адресов и максимальное количество записей в фильтрующем файле.

Следующие n cтрок содержат по одному IP адресу из черного списка в формате 100.200.X.Y, 0≤X,Y<256.

**Выходные данные**
В первой строке выведите минимально возможное количество запрещенных IP адресов не из черного списка.

Во второй строке выведите количество использованных записей в файле m (1≤m≤k).

В следующих m строках выведите сами записи.

Если ответов несколько, выведите любой.

**Примеры**

==Входные данные==
4 2
100.200.1.1
100.200.1.2
100.200.1.100
100.200.100.5
==Выходные данные==
253
2
100.200.1.0/24
100.200.100.5

==Входные данные==
2 1
100.200.3.4
100.200.5.6
==Выходные данные==
65534
1
100.200.0.0/16

==Входные данные==
4 100
100.200.3.4
100.200.5.6
100.200.6.7
100.200.8.9
==Выходные данные==
0
4
100.200.3.4
100.200.5.6
100.200.6.7
100.200.8.9



-----
**Zero-Links (Внутренние ссылки)** Линки - ключевые слова
-

------
**Links (Внешние ссылки)**
-
